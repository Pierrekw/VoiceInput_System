# å¼‚æ­¥å¤„ç†æ¡†æ¶è®¾è®¡ä¸å®ç°æ–¹æ¡ˆ

## 1. æ¦‚è¿°

æœ¬æ–¹æ¡ˆè¯¦ç»†ä»‹ç»äº†è¯­éŸ³è¾“å…¥ç³»ç»Ÿçš„å¼‚æ­¥å¤„ç†æ¡†æ¶è®¾è®¡ä¸å®ç°ï¼Œé‡ç‚¹è§£å†³ä»¥ä¸‹æ ¸å¿ƒé—®é¢˜ï¼š

- **å¼‚æ­¥ä»»åŠ¡ç”Ÿå‘½å‘¨æœŸç®¡ç†**ï¼šç¡®ä¿å¼‚æ­¥ä»»åŠ¡èƒ½å¤Ÿæ­£ç¡®åˆ›å»ºã€æ‰§è¡Œã€å–æ¶ˆå’Œæ¸…ç†
- **èµ„æºæ³„æ¼é˜²æ­¢**ï¼šé¿å…"Task was destroyed but it is pending!"é”™è¯¯
- **ç³»ç»Ÿç¨³å®šæ€§**ï¼šæä¾›å¥å£®çš„å¼‚å¸¸å¤„ç†å’Œèµ„æºå›æ”¶æœºåˆ¶
- **é«˜æ•ˆçš„äº‹ä»¶é©±åŠ¨æ¶æ„**ï¼šå®ç°æ¾è€¦åˆã€é«˜å¯æ‰©å±•çš„ç³»ç»Ÿè®¾è®¡

## 2. ç³»ç»Ÿæ¶æ„

### 2.1 æ€»ä½“æ¶æ„

å¼‚æ­¥å¤„ç†æ¡†æ¶é‡‡ç”¨äº‹ä»¶é©±åŠ¨ã€ç»„ä»¶åŒ–çš„æ¶æ„è®¾è®¡ï¼Œä¸»è¦åŒ…å«ä»¥ä¸‹å±‚æ¬¡ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    åº”ç”¨å±‚ (Application)                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  ç³»ç»Ÿå…¥å£     â”‚    â”‚  æ§åˆ¶ä¸­å¿ƒ (Controller)         â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    ä¸šåŠ¡é€»è¾‘å±‚ (Business)                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  è¯­éŸ³è¯†åˆ«     â”‚    â”‚  æ–‡æœ¬å¤„ç†     â”‚    â”‚  TTS    â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    æ•°æ®å±‚ (Data)                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  éŸ³é¢‘æµå¤„ç†   â”‚    â”‚  æ•°æ®å­˜å‚¨     â”‚    â”‚  é…ç½®   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    åŸºç¡€è®¾æ–½å±‚ (Infrastructure)           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  äº‹ä»¶æ€»çº¿     â”‚    â”‚  ä»»åŠ¡ç®¡ç†     â”‚    â”‚  æ—¥å¿—   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 æ ¸å¿ƒç»„ä»¶å…³ç³»

![ç»„ä»¶å…³ç³»å›¾]()

- **äº‹ä»¶æ€»çº¿**ï¼šè¿æ¥æ‰€æœ‰ç»„ä»¶ï¼Œå®ç°æ¾è€¦åˆé€šä¿¡
- **ä»»åŠ¡ç®¡ç†å™¨**ï¼šè´Ÿè´£å¼‚æ­¥ä»»åŠ¡çš„åˆ›å»ºã€è·Ÿè¸ªå’Œæ¸…ç†
- **èµ„æºç®¡ç†å™¨**ï¼šç®¡ç†ç³»ç»Ÿèµ„æºçš„åˆ†é…å’Œé‡Šæ”¾
- **éŸ³é¢‘æµæ§åˆ¶å™¨**ï¼šå¤„ç†éŸ³é¢‘æ•°æ®çš„é‡‡é›†å’Œæµå¤„ç†
- **é”™è¯¯å¤„ç†å™¨**ï¼šç»Ÿä¸€å¤„ç†ç³»ç»Ÿä¸­çš„å¼‚å¸¸æƒ…å†µ

## 3. å¼‚æ­¥ä»»åŠ¡ç®¡ç†æœºåˆ¶

### 3.1 ä»»åŠ¡åˆ›å»ºä¸è·Ÿè¸ª

```python
class AsyncTaskManager:
    """å¼‚æ­¥ä»»åŠ¡ç®¡ç†å™¨"""
    
    def __init__(self, max_concurrent_tasks=10, task_timeout=60):
        # ä»»åŠ¡é›†åˆï¼Œç”¨äºè·Ÿè¸ªæ‰€æœ‰æ´»åŠ¨ä»»åŠ¡
        self.tasks = set()
        # æœ€å¤§å¹¶å‘ä»»åŠ¡æ•°é™åˆ¶
        self.max_concurrent_tasks = max_concurrent_tasks
        # ä»»åŠ¡è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰
        self.task_timeout = task_timeout
        # ä»»åŠ¡IDè®¡æ•°å™¨
        self.task_counter = 0
        # ä»»åŠ¡æ˜ å°„è¡¨ï¼ˆä»»åŠ¡ID -> ä»»åŠ¡å¯¹è±¡ï¼‰
        self.task_map = {}
        # é”ï¼Œç”¨äºçº¿ç¨‹å®‰å…¨æ“ä½œ
        self._lock = asyncio.Lock()
    
    async def create_task(self, coro, task_name="Task", timeout=None):
        """åˆ›å»ºå¹¶è·Ÿè¸ªä¸€ä¸ªå¼‚æ­¥ä»»åŠ¡"""
        # è·å–é”ç¡®ä¿çº¿ç¨‹å®‰å…¨
        async with self._lock:
            # æ£€æŸ¥å¹¶å‘ä»»åŠ¡æ•°é™åˆ¶
            if len(self.tasks) >= self.max_concurrent_tasks:
                # ç­‰å¾…ä¸€äº›ä»»åŠ¡å®Œæˆæˆ–è¶…æ—¶
                await self._wait_for_task_slot()
            
            # ç”Ÿæˆä»»åŠ¡ID
            self.task_counter += 1
            task_id = f"{task_name}-{self.task_counter}"
            
            # åŒ…è£…åç¨‹ï¼Œæ·»åŠ è¶…æ—¶å’Œå¼‚å¸¸å¤„ç†
            wrapped_coro = self._wrap_coroutine(coro, task_id, timeout)
            
            # åˆ›å»ºä»»åŠ¡
            task = asyncio.create_task(wrapped_coro, name=task_id)
            
            # æ·»åŠ åˆ°ä»»åŠ¡é›†åˆ
            self.tasks.add(task)
            self.task_map[task_id] = task
            
            # æ·»åŠ å®Œæˆå›è°ƒï¼Œä»»åŠ¡å®Œæˆåä»é›†åˆä¸­ç§»é™¤
            task.add_done_callback(self._task_done_callback)
            
            return task_id
    
    async def _wrap_coroutine(self, coro, task_id, timeout=None):
        """åŒ…è£…åç¨‹ï¼Œæ·»åŠ è¶…æ—¶å’Œå¼‚å¸¸å¤„ç†"""
        try:
            # ä½¿ç”¨æä¾›çš„è¶…æ—¶æˆ–é»˜è®¤è¶…æ—¶
            timeout_val = timeout if timeout is not None else self.task_timeout
            
            # æ·»åŠ è¶…æ—¶æœºåˆ¶
            if timeout_val > 0:
                return await asyncio.wait_for(coro, timeout=timeout_val)
            else:
                return await coro
        except asyncio.TimeoutError:
            logging.warning(f"â±ï¸ ä»»åŠ¡è¶…æ—¶: {task_id}")
        except asyncio.CancelledError:
            logging.info(f"ğŸš« ä»»åŠ¡è¢«å–æ¶ˆ: {task_id}")
            raise  # é‡æ–°æŠ›å‡ºCancelledErrorï¼Œè®©ä»»åŠ¡çŠ¶æ€æ­£ç¡®åæ˜ ä¸ºå·²å–æ¶ˆ
        except Exception as e:
            logging.error(f"âŒ ä»»åŠ¡æ‰§è¡Œå¼‚å¸¸: {task_id}, é”™è¯¯: {e}")
        finally:
            # ç¡®ä¿ä»»åŠ¡èµ„æºè¢«æ¸…ç†
            pass
    
    def _task_done_callback(self, task):
        """ä»»åŠ¡å®Œæˆå›è°ƒ"""
        # ä»ä»»åŠ¡é›†åˆä¸­ç§»é™¤å·²å®Œæˆçš„ä»»åŠ¡
        if task in self.tasks:
            self.tasks.remove(task)
            
            # ä»ä»»åŠ¡æ˜ å°„è¡¨ä¸­ç§»é™¤
            for task_id, t in list(self.task_map.items()):
                if t == task:
                    del self.task_map[task_id]
                    break
        
        # æ£€æŸ¥ä»»åŠ¡æ˜¯å¦æœ‰å¼‚å¸¸
        try:
            task.result()  # è¿™ä¼šé‡æ–°æŠ›å‡ºä»»åŠ¡ä¸­çš„å¼‚å¸¸
        except asyncio.CancelledError:
            logging.debug(f"ğŸ”„ ä»»åŠ¡å·²å–æ¶ˆ: {task.get_name()}")
        except Exception as e:
            logging.error(f"âŒ ä»»åŠ¡å†…éƒ¨å¼‚å¸¸æœªæ•è·: {task.get_name()}, é”™è¯¯: {e}")
    
    async def _wait_for_task_slot(self):
        """ç­‰å¾…å¯ç”¨çš„ä»»åŠ¡æ§½ä½"""
        logging.warning(f"âš ï¸ è¾¾åˆ°æœ€å¤§å¹¶å‘ä»»åŠ¡æ•°: {self.max_concurrent_tasks}")
        
        # ç­‰å¾…æœ€çŸ­æ—¶é—´çš„ä»»åŠ¡å®Œæˆæˆ–è¶…æ—¶
        if self.tasks:
            # ç­‰å¾…ä»»æ„ä¸€ä¸ªä»»åŠ¡å®Œæˆ
            done, pending = await asyncio.wait(
                self.tasks, 
                return_when=asyncio.FIRST_COMPLETED, 
                timeout=1.0  # 1ç§’åè¶…æ—¶ï¼Œé¿å…æ— é™ç­‰å¾…
            )
            
            if not done:
                # å¦‚æœæ²¡æœ‰ä»»åŠ¡å®Œæˆï¼Œå–æ¶ˆæœ€è€çš„ä»»åŠ¡
                oldest_task = min(self.tasks, key=lambda t: t.get_name())
                logging.warning(f"ğŸ”„ å–æ¶ˆæœ€è€çš„ä»»åŠ¡: {oldest_task.get_name()}")
                oldest_task.cancel()
                try:
                    await oldest_task
                except asyncio.CancelledError:
                    pass
    
    async def cancel_task(self, task_id):
        """å–æ¶ˆæŒ‡å®šçš„ä»»åŠ¡"""
        async with self._lock:
            if task_id in self.task_map:
                task = self.task_map[task_id]
                if not task.done():
                    logging.info(f"ğŸš« å–æ¶ˆä»»åŠ¡: {task_id}")
                    task.cancel()
                    try:
                        # ç­‰å¾…ä»»åŠ¡è¢«å–æ¶ˆ
                        await asyncio.wait_for(asyncio.shield(task), timeout=2.0)
                    except asyncio.CancelledError:
                        pass
                    except asyncio.TimeoutError:
                        logging.warning(f"âš ï¸ ä»»åŠ¡å–æ¶ˆè¶…æ—¶: {task_id}")
                return True
            return False
    
    async def cancel_all_tasks(self):
        """å–æ¶ˆæ‰€æœ‰ä»»åŠ¡"""
        async with self._lock:
            tasks_to_cancel = list(self.tasks)
            
            if not tasks_to_cancel:
                return []
            
            logging.info(f"ğŸš« å–æ¶ˆæ‰€æœ‰ä»»åŠ¡ ({len(tasks_to_cancel)}ä¸ª)")
            
            # å–æ¶ˆæ‰€æœ‰ä»»åŠ¡
            for task in tasks_to_cancel:
                if not task.done():
                    task.cancel()
            
            # ç­‰å¾…æ‰€æœ‰ä»»åŠ¡è¢«å–æ¶ˆ
            results = []
            for task in tasks_to_cancel:
                try:
                    result = await asyncio.wait_for(asyncio.shield(task), timeout=1.0)
                    results.append((task.get_name(), True, result))
                except asyncio.CancelledError:
                    results.append((task.get_name(), True, None))
                except asyncio.TimeoutError:
                    results.append((task.get_name(), False, "Timeout"))
                except Exception as e:
                    results.append((task.get_name(), False, str(e)))
            
            # æ¸…ç©ºä»»åŠ¡é›†åˆ
            self.tasks.clear()
            self.task_map.clear()
            
            return results
    
    def get_task_count(self):
        """è·å–å½“å‰æ´»åŠ¨ä»»åŠ¡æ•°"""
        return len(self.tasks)
    
    def get_active_tasks(self):
        """è·å–æ‰€æœ‰æ´»åŠ¨ä»»åŠ¡çš„ä¿¡æ¯"""
        return [{
            'id': task.get_name(),
            'done': task.done(),
            'cancelled': task.cancelled()
        } for task in self.tasks]
```

### 3.2 å¼‚æ­¥ä»»åŠ¡çš„å–æ¶ˆä¸æ¸…ç†æœºåˆ¶

ä¸ºäº†è§£å†³"Task was destroyed but it is pending!"é”™è¯¯ï¼Œæ¡†æ¶å®ç°äº†å®Œå–„çš„ä»»åŠ¡å–æ¶ˆå’Œæ¸…ç†æœºåˆ¶ï¼š

1. **ä»»åŠ¡è·Ÿè¸ª**ï¼šæ‰€æœ‰åˆ›å»ºçš„ä»»åŠ¡éƒ½è¢«æ·»åŠ åˆ°é›†ä¸­ç®¡ç†çš„ä»»åŠ¡é›†åˆä¸­
2. **è¶…æ—¶æœºåˆ¶**ï¼šæ¯ä¸ªä»»åŠ¡éƒ½æœ‰è¶…æ—¶è®¾ç½®ï¼Œé¿å…ä»»åŠ¡æ— é™æœŸè¿è¡Œ
3. **ä¼˜é›…å–æ¶ˆ**ï¼šé€šè¿‡`task.cancel()`å’Œ`await task`ç»„åˆå®ç°ä»»åŠ¡çš„ä¼˜é›…å–æ¶ˆ
4. **èµ„æºå›æ”¶**ï¼šä»»åŠ¡å®Œæˆåè‡ªåŠ¨æ¸…ç†ç›¸å…³èµ„æº
5. **ç³»ç»Ÿå…³é—­æµç¨‹**ï¼šåœ¨ç³»ç»Ÿå…³é—­æ—¶ç¡®ä¿æ‰€æœ‰ä»»åŠ¡éƒ½è¢«æ­£ç¡®å–æ¶ˆå’Œæ¸…ç†

ä»¥ä¸‹æ˜¯ç³»ç»Ÿå…³é—­æ—¶çš„ä»»åŠ¡æ¸…ç†æµç¨‹ï¼š

```python
async def graceful_shutdown(self):
    """ä¼˜é›…å…³é—­ç³»ç»Ÿ"""
    logging.info("ğŸ›‘ å¼€å§‹ä¼˜é›…å…³é—­ç³»ç»Ÿ...")
    
    try:
        # 1. åœæ­¢æ¥å—æ–°ä»»åŠ¡
        self.running = False
        
        # 2. å–æ¶ˆæ‰€æœ‰ä»»åŠ¡
        cancel_results = await self.task_manager.cancel_all_tasks()
        
        # 3. è®°å½•ä»»åŠ¡å–æ¶ˆç»“æœ
        success_count = sum(1 for _, success, _ in cancel_results if success)
        fail_count = sum(1 for _, success, _ in cancel_results if not success)
        
        logging.info(f"âœ… ä»»åŠ¡å–æ¶ˆç»“æœ: æˆåŠŸ={success_count}, å¤±è´¥={fail_count}")
        
        # 4. æ¸…ç†èµ„æº
        await self._cleanup_resources()
        
        # 5. ç­‰å¾…ä¸€æ®µæ—¶é—´ç¡®ä¿æ‰€æœ‰èµ„æºéƒ½è¢«é‡Šæ”¾
        await asyncio.sleep(0.1)
        
        logging.info("âœ… ç³»ç»Ÿå·²ä¼˜é›…å…³é—­")
        return True
    except Exception as e:
        logging.error(f"âŒ ä¼˜é›…å…³é—­å¤±è´¥: {e}")
        return False
```

### 3.3 é˜²æ­¢èµ„æºæ³„æ¼çš„æœ€ä½³å®è·µ

1. **æ€»æ˜¯è·Ÿè¸ªä»»åŠ¡**ï¼šç¡®ä¿æ¯ä¸ªåˆ›å»ºçš„ä»»åŠ¡éƒ½è¢«æ·»åŠ åˆ°ä»»åŠ¡ç®¡ç†å™¨ä¸­
2. **ä½¿ç”¨asyncio.shield**ï¼šä¿æŠ¤å…³é”®ä»»åŠ¡ä¸è¢«æ„å¤–å–æ¶ˆ
3. **é¿å…é•¿æ—¶é—´é˜»å¡**ï¼šä¸è¦åœ¨å¼‚æ­¥ä»£ç ä¸­ä½¿ç”¨é˜»å¡å¼IOæ“ä½œ
4. **æ­£ç¡®å¤„ç†å¼‚å¸¸**ï¼šç‰¹åˆ«æ˜¯CancelledErrorå¼‚å¸¸
5. **é™åˆ¶å¹¶å‘ä»»åŠ¡æ•°**ï¼šé˜²æ­¢ç³»ç»Ÿèµ„æºè€—å°½
6. **ä½¿ç”¨ä¸Šä¸‹æ–‡ç®¡ç†å™¨**ï¼šè‡ªåŠ¨ç®¡ç†èµ„æºçš„åˆ†é…å’Œé‡Šæ”¾

## 4. äº‹ä»¶é©±åŠ¨æ¶æ„å®ç°

### 4.1 äº‹ä»¶æ€»çº¿è®¾è®¡

```python
class EventBus:
    """å¼‚æ­¥äº‹ä»¶æ€»çº¿"""
    
    def __init__(self):
        # äº‹ä»¶è®¢é˜…è€…æ˜ å°„è¡¨
        self.subscribers = {}
        # é”ï¼Œç”¨äºçº¿ç¨‹å®‰å…¨æ“ä½œ
        self._lock = asyncio.Lock()
    
    async def subscribe(self, event_type, subscriber):
        """è®¢é˜…äº‹ä»¶"""
        async with self._lock:
            if event_type not in self.subscribers:
                self.subscribers[event_type] = []
            
            if subscriber not in self.subscribers[event_type]:
                self.subscribers[event_type].append(subscriber)
                logging.debug(f"âœ… è®¢é˜…äº‹ä»¶: {event_type}, è®¢é˜…è€…: {subscriber.__class__.__name__}")
    
    async def unsubscribe(self, event_type, subscriber):
        """å–æ¶ˆè®¢é˜…äº‹ä»¶"""
        async with self._lock:
            if event_type in self.subscribers and subscriber in self.subscribers[event_type]:
                self.subscribers[event_type].remove(subscriber)
                logging.debug(f"âœ… å–æ¶ˆè®¢é˜…äº‹ä»¶: {event_type}, è®¢é˜…è€…: {subscriber.__class__.__name__}")
                
                # å¦‚æœæ²¡æœ‰è®¢é˜…è€…äº†ï¼Œç§»é™¤äº‹ä»¶ç±»å‹
                if not self.subscribers[event_type]:
                    del self.subscribers[event_type]
    
    async def publish(self, event_type, data=None):
        """å‘å¸ƒäº‹ä»¶"""
        # åˆ›å»ºäº‹ä»¶å¯¹è±¡
        event = {
            'type': event_type,
            'data': data,
            'timestamp': datetime.datetime.now()
        }
        
        # è·å–è®¢é˜…è€…åˆ—è¡¨çš„å‰¯æœ¬ï¼Œé¿å…åœ¨è¿­ä»£è¿‡ç¨‹ä¸­ä¿®æ”¹åˆ—è¡¨
        async with self._lock:
            if event_type not in self.subscribers:
                return []
            
            # åˆ›å»ºè®¢é˜…è€…åˆ—è¡¨çš„å‰¯æœ¬
            subscribers = self.subscribers[event_type].copy()
        
        # å¼‚æ­¥é€šçŸ¥æ‰€æœ‰è®¢é˜…è€…
        tasks = []
        for subscriber in subscribers:
            # ä¸ºæ¯ä¸ªè®¢é˜…è€…åˆ›å»ºä¸€ä¸ªä»»åŠ¡
            task = asyncio.create_task(self._notify_subscriber(subscriber, event))
            tasks.append(task)
        
        # ç­‰å¾…æ‰€æœ‰é€šçŸ¥ä»»åŠ¡å®Œæˆ
        if tasks:
            results = await asyncio.gather(*tasks, return_exceptions=True)
            
            # å¤„ç†å¼‚å¸¸
            for i, result in enumerate(results):
                if isinstance(result, Exception):
                    subscriber = subscribers[i]
                    logging.error(f"âŒ é€šçŸ¥è®¢é˜…è€…å¤±è´¥: {subscriber.__class__.__name__}, é”™è¯¯: {result}")
            
            return results
        
        return []
    
    async def _notify_subscriber(self, subscriber, event):
        """é€šçŸ¥å•ä¸ªè®¢é˜…è€…"""
        try:
            # æ£€æŸ¥subscriberæ˜¯å¦ä¸ºå¯è°ƒç”¨å¯¹è±¡
            if callable(subscriber):
                return await subscriber(event)
            # æ£€æŸ¥subscriberæ˜¯å¦æœ‰handle_eventæ–¹æ³•
            elif hasattr(subscriber, 'handle_event') and callable(subscriber.handle_event):
                return await subscriber.handle_event(event)
            else:
                logging.error(f"âŒ æ— æ•ˆçš„è®¢é˜…è€…: {subscriber}, ä¸æ˜¯å¯è°ƒç”¨å¯¹è±¡æˆ–æ²¡æœ‰handle_eventæ–¹æ³•")
                return None
        except Exception as e:
            logging.error(f"âŒ å¤„ç†äº‹ä»¶å¤±è´¥: {event['type']}, è®¢é˜…è€…: {subscriber.__class__.__name__}, é”™è¯¯: {e}")
            raise
    
    def get_subscriber_count(self, event_type=None):
        """è·å–è®¢é˜…è€…æ•°é‡"""
        if event_type:
            return len(self.subscribers.get(event_type, []))
        else:
            return sum(len(subscribers) for subscribers in self.subscribers.values())
```

### 4.2 äº‹ä»¶ç±»å‹å®šä¹‰

```python
class EventType:
    """äº‹ä»¶ç±»å‹å®šä¹‰"""
    # éŸ³é¢‘ç›¸å…³äº‹ä»¶
    AUDIO_DATA_AVAILABLE = "AUDIO_DATA_AVAILABLE"  # éŸ³é¢‘æ•°æ®å¯ç”¨
    AUDIO_STREAM_STARTED = "AUDIO_STREAM_STARTED"  # éŸ³é¢‘æµå¼€å§‹
    AUDIO_STREAM_STOPPED = "AUDIO_STREAM_STOPPED"  # éŸ³é¢‘æµåœæ­¢
    
    # è¯†åˆ«ç›¸å…³äº‹ä»¶
    RECOGNITION_STARTED = "RECOGNITION_STARTED"    # è¯†åˆ«å¼€å§‹
    RECOGNITION_COMPLETE = "RECOGNITION_COMPLETE"  # è¯†åˆ«å®Œæˆ
    RECOGNITION_FAILED = "RECOGNITION_FAILED"      # è¯†åˆ«å¤±è´¥
    
    # æ–‡æœ¬å¤„ç†ç›¸å…³äº‹ä»¶
    TEXT_PROCESSED = "TEXT_PROCESSED"              # æ–‡æœ¬å¤„ç†å®Œæˆ
    MEASUREMENT_EXTRACTED = "MEASUREMENT_EXTRACTED"  # æ•°å€¼æå–å®Œæˆ
    
    # TTSç›¸å…³äº‹ä»¶
    TTS_SPEAK_STARTED = "TTS_SPEAK_STARTED"        # TTSå¼€å§‹æ’­æŠ¥
    TTS_SPEAK_COMPLETE = "TTS_SPEAK_COMPLETE"      # TTSæ’­æŠ¥å®Œæˆ
    TTS_SPEAK_FAILED = "TTS_SPEAK_FAILED"          # TTSæ’­æŠ¥å¤±è´¥
    
    # æ•°æ®å­˜å‚¨ç›¸å…³äº‹ä»¶
    DATA_EXPORT_STARTED = "DATA_EXPORT_STARTED"    # æ•°æ®å¯¼å‡ºå¼€å§‹
    DATA_EXPORT_COMPLETE = "DATA_EXPORT_COMPLETE"  # æ•°æ®å¯¼å‡ºå®Œæˆ
    DATA_EXPORT_FAILED = "DATA_EXPORT_FAILED"      # æ•°æ®å¯¼å‡ºå¤±è´¥
    
    # ç³»ç»Ÿç›¸å…³äº‹ä»¶
    SYSTEM_STARTED = "SYSTEM_STARTED"              # ç³»ç»Ÿå¯åŠ¨
    SYSTEM_STOPPED = "SYSTEM_STOPPED"              # ç³»ç»Ÿåœæ­¢
    ERROR_OCCURRED = "ERROR_OCCURRED"              # å‘ç”Ÿé”™è¯¯
    WARNING_OCCURRED = "WARNING_OCCURRED"          # å‘ç”Ÿè­¦å‘Š
    
    # é…ç½®ç›¸å…³äº‹ä»¶
    CONFIG_CHANGED = "CONFIG_CHANGED"              # é…ç½®å˜æ›´
    
    # è°ƒè¯•ç›¸å…³äº‹ä»¶
    DEBUG_INFO = "DEBUG_INFO"                      # è°ƒè¯•ä¿¡æ¯
```

## 5. éŸ³é¢‘æµå¤„ç†å®ç°

### 5.1 å¼‚æ­¥éŸ³é¢‘æµæ§åˆ¶å™¨

```python
class AsyncAudioStreamController:
    """å¼‚æ­¥éŸ³é¢‘æµæ§åˆ¶å™¨"""
    
    def __init__(self, config=None):
        # é…ç½®
        self.config = config or {}
        self.sample_rate = self.config.get('sample_rate', 16000)
        self.channels = self.config.get('channels', 1)
        self.format = self.config.get('format', 16)
        self.chunk_size = self.config.get('chunk_size', 4096)
        
        # éŸ³é¢‘æµçŠ¶æ€
        self.running = False
        self.audio_stream = None
        self.audio_source = None
        
        # å›è°ƒå‡½æ•°
        self.callbacks = {}
        
        # ä»»åŠ¡å¼•ç”¨
        self.stream_task = None
        
        # ç¼“å†²åŒº
        self.buffer = asyncio.Queue(maxsize=10)
    
    async def start(self):
        """å¯åŠ¨éŸ³é¢‘æµ"""
        if self.running:
            logging.warning("âš ï¸ éŸ³é¢‘æµå·²ç»åœ¨è¿è¡Œä¸­")
            return False
        
        try:
            logging.info(f"â–¶ï¸ å¯åŠ¨éŸ³é¢‘æµ: é‡‡æ ·ç‡={self.sample_rate}, é€šé“={self.channels}, å—å¤§å°={self.chunk_size}")
            
            # åˆå§‹åŒ–éŸ³é¢‘æº
            await self._initialize_audio_source()
            
            # åˆ›å»ºéŸ³é¢‘æµä»»åŠ¡
            self.running = True
            self.stream_task = asyncio.create_task(self._audio_stream_task())
            
            # å‘å¸ƒéŸ³é¢‘æµå¯åŠ¨äº‹ä»¶
            await self._notify_callbacks(EventType.AUDIO_STREAM_STARTED, {
                'sample_rate': self.sample_rate,
                'channels': self.channels,
                'format': self.format,
                'chunk_size': self.chunk_size
            })
            
            logging.info("âœ… éŸ³é¢‘æµå¯åŠ¨æˆåŠŸ")
            return True
        except Exception as e:
            logging.error(f"âŒ éŸ³é¢‘æµå¯åŠ¨å¤±è´¥: {e}")
            self.running = False
            await self._cleanup_audio_source()
            return False
    
    async def stop(self):
        """åœæ­¢éŸ³é¢‘æµ"""
        if not self.running:
            logging.warning("âš ï¸ éŸ³é¢‘æµå·²ç»åœæ­¢")
            return False
        
        try:
            logging.info("â¹ï¸ åœæ­¢éŸ³é¢‘æµ...")
            
            # åœæ­¢è¿è¡Œæ ‡å¿—
            self.running = False
            
            # å–æ¶ˆéŸ³é¢‘æµä»»åŠ¡
            if self.stream_task and not self.stream_task.done():
                self.stream_task.cancel()
                try:
                    await asyncio.wait_for(asyncio.shield(self.stream_task), timeout=2.0)
                except asyncio.CancelledError:
                    pass
                except asyncio.TimeoutError:
                    logging.warning("âš ï¸ éŸ³é¢‘æµä»»åŠ¡å–æ¶ˆè¶…æ—¶")
            
            # æ¸…ç†éŸ³é¢‘æº
            await self._cleanup_audio_source()
            
            # æ¸…ç©ºç¼“å†²åŒº
            while not self.buffer.empty():
                try:
                    self.buffer.get_nowait()
                    self.buffer.task_done()
                except asyncio.QueueEmpty:
                    break
            
            # å‘å¸ƒéŸ³é¢‘æµåœæ­¢äº‹ä»¶
            await self._notify_callbacks(EventType.AUDIO_STREAM_STOPPED)
            
            logging.info("âœ… éŸ³é¢‘æµåœæ­¢æˆåŠŸ")
            return True
        except Exception as e:
            logging.error(f"âŒ éŸ³é¢‘æµåœæ­¢å¤±è´¥: {e}")
            return False
    
    async def _initialize_audio_source(self):
        """åˆå§‹åŒ–éŸ³é¢‘æº"""
        # è¿™é‡Œåº”è¯¥æ ¹æ®å®é™…æƒ…å†µåˆå§‹åŒ–éŸ³é¢‘æº
        # ä¾‹å¦‚ä½¿ç”¨PyAudioã€sounddeviceç­‰åº“
        # ä»¥ä¸‹æ˜¯ä¸€ä¸ªç¤ºä¾‹å®ç°
        try:
            # æ¨¡æ‹ŸéŸ³é¢‘æºåˆå§‹åŒ–
            logging.info("ğŸ¤ åˆå§‹åŒ–éŸ³é¢‘æº...")
            # self.audio_source = ...  # å®é™…çš„éŸ³é¢‘æºåˆå§‹åŒ–ä»£ç 
        except Exception as e:
            logging.error(f"âŒ éŸ³é¢‘æºåˆå§‹åŒ–å¤±è´¥: {e}")
            raise
    
    async def _cleanup_audio_source(self):
        """æ¸…ç†éŸ³é¢‘æº"""
        try:
            if self.audio_source:
                # æ¨¡æ‹ŸéŸ³é¢‘æºæ¸…ç†
                logging.info("ğŸ¤ æ¸…ç†éŸ³é¢‘æº...")
                # self.audio_source.close()  # å®é™…çš„éŸ³é¢‘æºæ¸…ç†ä»£ç 
                self.audio_source = None
        except Exception as e:
            logging.error(f"âŒ éŸ³é¢‘æºæ¸…ç†å¤±è´¥: {e}")
    
    async def _audio_stream_task(self):
        """éŸ³é¢‘æµå¤„ç†ä»»åŠ¡"""
        try:
            logging.info("ğŸ”„ è¿›å…¥éŸ³é¢‘æµå¤„ç†å¾ªç¯")
            
            while self.running:
                try:
                    # æ¨¡æ‹Ÿè·å–éŸ³é¢‘æ•°æ®
                    # åœ¨å®é™…å®ç°ä¸­ï¼Œè¿™é‡Œåº”è¯¥ä»éŸ³é¢‘æºè¯»å–æ•°æ®
                    audio_data = self._get_audio_data()
                    
                    if audio_data:
                        # å°†éŸ³é¢‘æ•°æ®æ”¾å…¥ç¼“å†²åŒº
                        try:
                            await asyncio.wait_for(
                                self.buffer.put(audio_data), 
                                timeout=0.1
                            )
                            
                            # å‘å¸ƒéŸ³é¢‘æ•°æ®å¯ç”¨äº‹ä»¶
                            await self._notify_callbacks(EventType.AUDIO_DATA_AVAILABLE, audio_data)
                        except asyncio.TimeoutError:
                            # ç¼“å†²åŒºå·²æ»¡ï¼Œä¸¢å¼ƒæ•°æ®
                            logging.warning("âš ï¸ éŸ³é¢‘ç¼“å†²åŒºå·²æ»¡ï¼Œä¸¢å¼ƒæ•°æ®")
                            # å¯ä»¥é€‰æ‹©æ¸…ç©ºç¼“å†²åŒº
                            # while not self.buffer.empty():
                            #     self.buffer.get_nowait()
                            #     self.buffer.task_done()
                except Exception as e:
                    logging.error(f"âŒ éŸ³é¢‘æ•°æ®è·å–å¤±è´¥: {e}")
                    # çŸ­æš‚æš‚åœåç»§ç»­
                    await asyncio.sleep(0.01)
                
                # çŸ­æš‚æš‚åœï¼Œé¿å…CPUå ç”¨è¿‡é«˜
                await asyncio.sleep(0.001)
        except asyncio.CancelledError:
            logging.info("ğŸš« éŸ³é¢‘æµä»»åŠ¡è¢«å–æ¶ˆ")
            raise
        except Exception as e:
            logging.error(f"âŒ éŸ³é¢‘æµä»»åŠ¡å¼‚å¸¸: {e}")
            # å‘å¸ƒé”™è¯¯äº‹ä»¶
            await self._notify_callbacks(EventType.ERROR_OCCURRED, {
                'error': str(e),
                'context': 'éŸ³é¢‘æµå¤„ç†'
            })
    
    def _get_audio_data(self):
        """è·å–éŸ³é¢‘æ•°æ®ï¼ˆæ¨¡æ‹Ÿå®ç°ï¼‰"""
        # åœ¨å®é™…å®ç°ä¸­ï¼Œè¿™é‡Œåº”è¯¥ä»éŸ³é¢‘æºè¯»å–æ•°æ®
        # ä¾‹å¦‚ä½¿ç”¨PyAudioçš„stream.read()æ–¹æ³•
        return b""  # è¿”å›å®é™…çš„éŸ³é¢‘æ•°æ®
    
    def register_callback(self, event_type, callback):
        """æ³¨å†Œå›è°ƒå‡½æ•°"""
        if event_type not in self.callbacks:
            self.callbacks[event_type] = []
        
        if callback not in self.callbacks[event_type]:
            self.callbacks[event_type].append(callback)
            logging.debug(f"âœ… æ³¨å†Œå›è°ƒ: {event_type}, å›è°ƒ: {callback.__name__}")
    
    def unregister_callback(self, event_type, callback):
        """å–æ¶ˆæ³¨å†Œå›è°ƒå‡½æ•°"""
        if event_type in self.callbacks and callback in self.callbacks[event_type]:
            self.callbacks[event_type].remove(callback)
            logging.debug(f"âœ… å–æ¶ˆæ³¨å†Œå›è°ƒ: {event_type}, å›è°ƒ: {callback.__name__}")
    
    async def _notify_callbacks(self, event_type, data=None):
        """é€šçŸ¥æ‰€æœ‰æ³¨å†Œçš„å›è°ƒå‡½æ•°"""
        if event_type in self.callbacks:
            # ä¸ºæ¯ä¸ªå›è°ƒåˆ›å»ºä¸€ä¸ªä»»åŠ¡
            tasks = []
            for callback in self.callbacks[event_type]:
                if callable(callback):
                    # æ£€æŸ¥æ˜¯å¦æ˜¯åç¨‹å‡½æ•°
                    if asyncio.iscoroutinefunction(callback):
                        task = asyncio.create_task(callback(data))
                        tasks.append(task)
                    else:
                        # å¯¹äºåŒæ­¥å›è°ƒï¼Œä½¿ç”¨çº¿ç¨‹æ± æ‰§è¡Œ
                        loop = asyncio.get_event_loop()
                        task = loop.run_in_executor(
                            None, 
                            lambda: self._safe_execute_callback(callback, data)
                        )
                        tasks.append(task)
            
            # ç­‰å¾…æ‰€æœ‰å›è°ƒä»»åŠ¡å®Œæˆ
            if tasks:
                await asyncio.gather(*tasks, return_exceptions=True)
    
    def _safe_execute_callback(self, callback, data):
        """å®‰å…¨æ‰§è¡ŒåŒæ­¥å›è°ƒå‡½æ•°"""
        try:
            callback(data)
        except Exception as e:
            logging.error(f"âŒ å›è°ƒæ‰§è¡Œå¤±è´¥: {callback.__name__}, é”™è¯¯: {e}")
    
    async def get_audio_data(self, timeout=None):
        """ä»ç¼“å†²åŒºè·å–éŸ³é¢‘æ•°æ®"""
        try:
            if timeout is not None:
                return await asyncio.wait_for(self.buffer.get(), timeout=timeout)
            else:
                return await self.buffer.get()
        except asyncio.TimeoutError:
            logging.warning("âš ï¸ è·å–éŸ³é¢‘æ•°æ®è¶…æ—¶")
            return None
    
    def is_running(self):
        """æ£€æŸ¥éŸ³é¢‘æµæ˜¯å¦æ­£åœ¨è¿è¡Œ"""
        return self.running
    
    def get_buffer_size(self):
        """è·å–ç¼“å†²åŒºä¸­çš„æ•°æ®é‡"""
        return self.buffer.qsize()
```

## 6. å¼‚æ­¥TTSç®¡ç†å™¨å®ç°

```python
class AsyncTTSManager:
    """å¼‚æ­¥TTSç®¡ç†å™¨"""
    
    def __init__(self, config=None):
        # é…ç½®
        self.config = config or {}
        self.voice = self.config.get('voice', 'zh-CN')
        self.speed = self.config.get('speed', 1.0)
        self.volume = self.config.get('volume', 1.0)
        
        # TTSå¼•æ“
        self.tts_engine = None
        self.audio_player = None
        
        # çŠ¶æ€
        self.initialized = False
        self.speaking = False
        
        # éŸ³é¢‘é˜Ÿåˆ—
        self.audio_queue = asyncio.Queue(maxsize=5)
        
        # æ’­æ”¾ä»»åŠ¡
        self.playback_task = None
        
        # è¯­éŸ³åé¦ˆå…³é”®è¯ï¼Œç”¨äºæ£€æµ‹ç³»ç»Ÿè‡ªèº«çš„TTSè¾“å‡º
        self.tts_feedback_keywords = ["æˆåŠŸæå–", "è¯†åˆ«åˆ°", "å·²è®°å½•", "æ•°å€¼æ˜¯", "ç»“æœæ˜¯"]
    
    async def initialize(self):
        """åˆå§‹åŒ–TTSç®¡ç†å™¨"""
        if self.initialized:
            logging.warning("âš ï¸ TTSç®¡ç†å™¨å·²ç»åˆå§‹åŒ–")
            return True
        
        try:
            logging.info(f"ğŸ”Š åˆå§‹åŒ–TTSç®¡ç†å™¨: è¯­éŸ³={self.voice}, è¯­é€Ÿ={self.speed}, éŸ³é‡={self.volume}")
            
            # åˆå§‹åŒ–TTSå¼•æ“
            await self._initialize_tts_engine()
            
            # åˆå§‹åŒ–éŸ³é¢‘æ’­æ”¾å™¨
            await self._initialize_audio_player()
            
            # åˆ›å»ºæ’­æ”¾ä»»åŠ¡
            self.playback_task = asyncio.create_task(self._playback_task())
            
            self.initialized = True
            logging.info("âœ… TTSç®¡ç†å™¨åˆå§‹åŒ–æˆåŠŸ")
            return True
        except Exception as e:
            logging.error(f"âŒ TTSç®¡ç†å™¨åˆå§‹åŒ–å¤±è´¥: {e}")
            await self.cleanup()
            return False
    
    async def _initialize_tts_engine(self):
        """åˆå§‹åŒ–TTSå¼•æ“"""
        # è¿™é‡Œåº”è¯¥æ ¹æ®å®é™…æƒ…å†µåˆå§‹åŒ–TTSå¼•æ“
        # ä¾‹å¦‚ä½¿ç”¨piper-ttsã€pyttsx3ç­‰åº“
        # ä»¥ä¸‹æ˜¯ä¸€ä¸ªç¤ºä¾‹å®ç°
        try:
            logging.info("ğŸ”Š åˆå§‹åŒ–TTSå¼•æ“...")
            # self.tts_engine = ...  # å®é™…çš„TTSå¼•æ“åˆå§‹åŒ–ä»£ç 
        except Exception as e:
            logging.error(f"âŒ TTSå¼•æ“åˆå§‹åŒ–å¤±è´¥: {e}")
            raise
    
    async def _initialize_audio_player(self):
        """åˆå§‹åŒ–éŸ³é¢‘æ’­æ”¾å™¨"""
        # è¿™é‡Œåº”è¯¥æ ¹æ®å®é™…æƒ…å†µåˆå§‹åŒ–éŸ³é¢‘æ’­æ”¾å™¨
        # ä¾‹å¦‚ä½¿ç”¨PyAudioã€sounddeviceç­‰åº“
        # ä»¥ä¸‹æ˜¯ä¸€ä¸ªç¤ºä¾‹å®ç°
        try:
            logging.info("ğŸ”Š åˆå§‹åŒ–éŸ³é¢‘æ’­æ”¾å™¨...")
            # self.audio_player = ...  # å®é™…çš„éŸ³é¢‘æ’­æ”¾å™¨åˆå§‹åŒ–ä»£ç 
        except Exception as e:
            logging.error(f"âŒ éŸ³é¢‘æ’­æ”¾å™¨åˆå§‹åŒ–å¤±è´¥: {e}")
            raise
    
    async def speak(self, text):
        """å¼‚æ­¥æ’­æ”¾æ–‡æœ¬"""
        if not self.initialized:
            logging.error("âŒ TTSç®¡ç†å™¨æœªåˆå§‹åŒ–")
            return False
        
        try:
            logging.debug(f"ğŸ”Š å‡†å¤‡æ’­æŠ¥: {text}")
            
            # æ£€æŸ¥æ˜¯å¦ä¸ºç³»ç»Ÿè‡ªèº«çš„TTSåé¦ˆï¼ˆé¿å…å¾ªç¯ï¼‰
            if self._is_tts_feedback(text):
                logging.warning(f"âš ï¸ æ£€æµ‹åˆ°TTSåé¦ˆæ–‡æœ¬ï¼Œè·³è¿‡æ’­æŠ¥: {text}")
                return False
            
            # ç”ŸæˆéŸ³é¢‘æ•°æ®
            audio_data = await self._generate_speech(text)
            
            if not audio_data:
                logging.error("âŒ ç”Ÿæˆè¯­éŸ³æ•°æ®å¤±è´¥")
                return False
            
            # å°†éŸ³é¢‘æ•°æ®æ”¾å…¥é˜Ÿåˆ—
            try:
                await asyncio.wait_for(self.audio_queue.put(audio_data), timeout=1.0)
            except asyncio.TimeoutError:
                logging.error("âŒ éŸ³é¢‘é˜Ÿåˆ—å·²æ»¡ï¼Œæ— æ³•æ·»åŠ æ–°çš„è¯­éŸ³æ•°æ®")
                return False
            
            # å‘å¸ƒTTSå¼€å§‹æ’­æŠ¥äº‹ä»¶
            await self._publish_event(EventType.TTS_SPEAK_STARTED, {
                'text': text
            })
            
            return True
        except Exception as e:
            logging.error(f"âŒ TTSæ’­æŠ¥å¤±è´¥: {e}")
            # å‘å¸ƒTTSæ’­æŠ¥å¤±è´¥äº‹ä»¶
            await self._publish_event(EventType.TTS_SPEAK_FAILED, {
                'text': text,
                'error': str(e)
            })
            return False
    
    def _is_tts_feedback(self, text):
        """æ£€æŸ¥æ–‡æœ¬æ˜¯å¦ä¸ºç³»ç»Ÿè‡ªèº«çš„TTSåé¦ˆ"""
        # æ£€æŸ¥æ˜¯å¦åŒ…å«ä»»ä½•TTSåé¦ˆå…³é”®è¯
        return any(keyword in text for keyword in self.tts_feedback_keywords)
    
    async def _generate_speech(self, text):
        """ç”Ÿæˆè¯­éŸ³æ•°æ®"""
        # åœ¨å®é™…å®ç°ä¸­ï¼Œè¿™é‡Œåº”è¯¥ä½¿ç”¨TTSå¼•æ“å°†æ–‡æœ¬è½¬æ¢ä¸ºéŸ³é¢‘æ•°æ®
        # ä»¥ä¸‹æ˜¯ä¸€ä¸ªç¤ºä¾‹å®ç°
        try:
            logging.debug(f"ğŸ”Š ç”Ÿæˆè¯­éŸ³æ•°æ®: {text}")
            # audio_data = self.tts_engine.synthesize(text, voice=self.voice, speed=self.speed)
            return b""  # è¿”å›å®é™…çš„éŸ³é¢‘æ•°æ®
        except Exception as e:
            logging.error(f"âŒ ç”Ÿæˆè¯­éŸ³æ•°æ®å¤±è´¥: {e}")
            raise
    
    async def _playback_task(self):
        """éŸ³é¢‘æ’­æ”¾ä»»åŠ¡"""
        try:
            logging.info("ğŸ”„ è¿›å…¥TTSæ’­æ”¾å¾ªç¯")
            
            while self.initialized:
                try:
                    # ä»é˜Ÿåˆ—è·å–éŸ³é¢‘æ•°æ®
                    audio_data = await self.audio_queue.get()
                    
                    if audio_data:
                        # æ’­æ”¾éŸ³é¢‘æ•°æ®
                        await self._play_audio(audio_data)
                        
                    # æ ‡è®°ä»»åŠ¡å®Œæˆ
                    self.audio_queue.task_done()
                except Exception as e:
                    logging.error(f"âŒ éŸ³é¢‘æ’­æ”¾å¤±è´¥: {e}")
                    # ç¡®ä¿ä»»åŠ¡æ ‡è®°ä¸ºå®Œæˆ
                    if not self.audio_queue.empty():
                        self.audio_queue.task_done()
        except asyncio.CancelledError:
            logging.info("ğŸš« TTSæ’­æ”¾ä»»åŠ¡è¢«å–æ¶ˆ")
            raise
        except Exception as e:
            logging.error(f"âŒ TTSæ’­æ”¾ä»»åŠ¡å¼‚å¸¸: {e}")
    
    async def _play_audio(self, audio_data):
        """æ’­æ”¾éŸ³é¢‘æ•°æ®"""
        # åœ¨å®é™…å®ç°ä¸­ï¼Œè¿™é‡Œåº”è¯¥ä½¿ç”¨éŸ³é¢‘æ’­æ”¾å™¨æ’­æ”¾éŸ³é¢‘æ•°æ®
        # ä»¥ä¸‹æ˜¯ä¸€ä¸ªç¤ºä¾‹å®ç°
        try:
            self.speaking = True
            logging.debug("ğŸ”Š å¼€å§‹æ’­æ”¾éŸ³é¢‘...")
            # await self.audio_player.play(audio_data)  # å®é™…çš„éŸ³é¢‘æ’­æ”¾ä»£ç 
            
            # æ¨¡æ‹Ÿæ’­æ”¾å»¶è¿Ÿ
            await asyncio.sleep(0.5)  # æ ¹æ®å®é™…éŸ³é¢‘é•¿åº¦è°ƒæ•´
            
            logging.debug("ğŸ”Š éŸ³é¢‘æ’­æ”¾å®Œæˆ")
            
            # å‘å¸ƒTTSæ’­æŠ¥å®Œæˆäº‹ä»¶
            await self._publish_event(EventType.TTS_SPEAK_COMPLETE)
        except Exception as e:
            logging.error(f"âŒ éŸ³é¢‘æ’­æ”¾å¤±è´¥: {e}")
            # å‘å¸ƒTTSæ’­æŠ¥å¤±è´¥äº‹ä»¶
            await self._publish_event(EventType.TTS_SPEAK_FAILED, {
                'error': str(e)
            })
        finally:
            self.speaking = False
    
    async def cleanup(self):
        """æ¸…ç†èµ„æº"""
        try:
            logging.info("ğŸ”Š æ¸…ç†TTSèµ„æº...")
            
            # åœæ­¢æ’­æ”¾ä»»åŠ¡
            if self.playback_task and not self.playback_task.done():
                self.playback_task.cancel()
                try:
                    await asyncio.wait_for(asyncio.shield(self.playback_task), timeout=2.0)
                except asyncio.CancelledError:
                    pass
                except asyncio.TimeoutError:
                    logging.warning("âš ï¸ TTSæ’­æ”¾ä»»åŠ¡å–æ¶ˆè¶…æ—¶")
            
            # æ¸…ç†éŸ³é¢‘æ’­æ”¾å™¨
            if self.audio_player:
                logging.info("ğŸ”Š æ¸…ç†éŸ³é¢‘æ’­æ”¾å™¨...")
                # await self.audio_player.cleanup()  # å®é™…çš„éŸ³é¢‘æ’­æ”¾å™¨æ¸…ç†ä»£ç 
                self.audio_player = None
            
            # æ¸…ç†TTSå¼•æ“
            if self.tts_engine:
                logging.info("ğŸ”Š æ¸…ç†TTSå¼•æ“...")
                # await self.tts_engine.shutdown()  # å®é™…çš„TTSå¼•æ“æ¸…ç†ä»£ç 
                self.tts_engine = None
            
            # æ¸…ç©ºéŸ³é¢‘é˜Ÿåˆ—
            while not self.audio_queue.empty():
                try:
                    self.audio_queue.get_nowait()
                    self.audio_queue.task_done()
                except asyncio.QueueEmpty:
                    break
            
            self.initialized = False
            self.speaking = False
            
            logging.info("âœ… TTSèµ„æºæ¸…ç†å®Œæˆ")
        except Exception as e:
            logging.error(f"âŒ TTSèµ„æºæ¸…ç†å¤±è´¥: {e}")
    
    async def _publish_event(self, event_type, data=None):
        """å‘å¸ƒäº‹ä»¶"""
        # åœ¨å®é™…å®ç°ä¸­ï¼Œè¿™é‡Œåº”è¯¥ä½¿ç”¨äº‹ä»¶æ€»çº¿å‘å¸ƒäº‹ä»¶
        # ä»¥ä¸‹æ˜¯ä¸€ä¸ªç¤ºä¾‹å®ç°
        logging.debug(f"ğŸ“¡ å‘å¸ƒTTSäº‹ä»¶: {event_type}, æ•°æ®: {data}")
        # await event_bus.publish(event_type, data)  # å®é™…çš„äº‹ä»¶å‘å¸ƒä»£ç 
    
    def is_speaking(self):
        """æ£€æŸ¥æ˜¯å¦æ­£åœ¨æ’­æ”¾éŸ³é¢‘"""
        return self.speaking
    
    def is_initialized(self):
        """æ£€æŸ¥TTSç®¡ç†å™¨æ˜¯å¦å·²åˆå§‹åŒ–"""
        return self.initialized
    
    def get_queue_size(self):
        """è·å–éŸ³é¢‘é˜Ÿåˆ—ä¸­çš„ä»»åŠ¡æ•°"""
        return self.audio_queue.qsize()
```

## 7. ç³»ç»Ÿé›†æˆç¤ºä¾‹

### 7.1 ä¸»ç³»ç»Ÿç±»å®ç°

```python
class AsyncVoiceInputSystem:
    """å¼‚æ­¥è¯­éŸ³è¾“å…¥ç³»ç»Ÿä¸»ç±»"""
    
    def __init__(self):
        # ç³»ç»ŸçŠ¶æ€
        self.running = False
        
        # äº‹ä»¶å¾ªç¯
        self.loop = asyncio.get_event_loop()
        
        # æ ¸å¿ƒç»„ä»¶
        self.config = None
        self.event_bus = None
        self.task_manager = None
        self.audio_stream_controller = None
        self.voice_recognizer = None
        self.text_processor = None
        self.tts_manager = None
        self.data_exporter = None
        self.error_handler = None
        
        # åˆå§‹åŒ–ç³»ç»Ÿ
        self._initialize_components()
    
    def _initialize_components(self):
        """åˆå§‹åŒ–ç³»ç»Ÿç»„ä»¶"""
        logging.info("ğŸš€ åˆå§‹åŒ–å¼‚æ­¥è¯­éŸ³è¾“å…¥ç³»ç»Ÿ...")
        
        try:
            # åŠ è½½é…ç½®
            self.config = self._load_config()
            
            # åˆ›å»ºäº‹ä»¶æ€»çº¿
            self.event_bus = EventBus()
            
            # åˆ›å»ºä»»åŠ¡ç®¡ç†å™¨
            self.task_manager = AsyncTaskManager(
                max_concurrent_tasks=self.config.get('async_specific.max_concurrent_tasks', 10),
                task_timeout=self.config.get('async_specific.task_timeout', 60)
            )
            
            # åˆ›å»ºé”™è¯¯å¤„ç†å™¨
            self.error_handler = ErrorHandler(self.event_bus)
            
            # åˆ›å»ºéŸ³é¢‘æµæ§åˆ¶å™¨
            self.audio_stream_controller = AsyncAudioStreamController({
                'sample_rate': self.config.get('audio.sample_rate', 16000),
                'channels': self.config.get('audio.channels', 1),
                'chunk_size': self.config.get('audio.chunk_size', 4096)
            })
            
            # æ³¨å†ŒéŸ³é¢‘æ•°æ®å›è°ƒ
            self.audio_stream_controller.register_callback(
                EventType.AUDIO_DATA_AVAILABLE, 
                self._handle_audio_data_available
            )
            
            # åˆ›å»ºè¯­éŸ³è¯†åˆ«å™¨
            self.voice_recognizer = AsyncVoiceRecognizer({
                'model_path': self.config.get('recognition.model_path', 'models'),
                'language': self.config.get('recognition.language', 'zh-CN')
            })
            
            # åˆ›å»ºæ–‡æœ¬å¤„ç†å™¨
            self.text_processor = TextProcessor({
                'error_correction': self.config.get('error_correction.enabled', True)
            })
            
            # åˆ›å»ºTTSç®¡ç†å™¨
            if self.config.get('tts.enabled', True):
                self.tts_manager = AsyncTTSManager({
                    'voice': self.config.get('tts.voice', 'zh-CN'),
                    'speed': self.config.get('tts.speed', 1.0),
                    'volume': self.config.get('tts.volume', 1.0)
                })
            
            # åˆ›å»ºæ•°æ®å¯¼å‡ºå™¨
            if self.config.get('excel.auto_export', True):
                self.data_exporter = DataExporter({
                    'file_path': self.config.get('excel.file_path', 'voice_data.xlsx'),
                    'sheet_name': self.config.get('excel.sheet_name', 'Data')
                })
            
            # æ³¨å†Œäº‹ä»¶å¤„ç†å™¨
            self._register_event_handlers()
            
            logging.info("âœ… ç³»ç»Ÿç»„ä»¶åˆå§‹åŒ–å®Œæˆ")
        except Exception as e:
            logging.error(f"âŒ ç³»ç»Ÿç»„ä»¶åˆå§‹åŒ–å¤±è´¥: {e}")
            raise
    
    def _load_config(self):
        """åŠ è½½é…ç½®"""
        # è¿™é‡Œåº”è¯¥ä»é…ç½®æ–‡ä»¶åŠ è½½é…ç½®
        # ä»¥ä¸‹æ˜¯ä¸€ä¸ªç¤ºä¾‹å®ç°
        return {
            'audio': {
                'sample_rate': 16000,
                'channels': 1,
                'chunk_size': 4096
            },
            'recognition': {
                'model_path': 'models',
                'language': 'zh-CN'
            },
            'tts': {
                'enabled': True,
                'voice': 'zh-CN',
                'speed': 1.0,
                'volume': 1.0
            },
            'excel': {
                'auto_export': True,
                'file_path': 'voice_data.xlsx',
                'sheet_name': 'Data'
            },
            'error_correction': {
                'enabled': True
            },
            'async_specific': {
                'max_concurrent_tasks': 10,
                'task_timeout': 60
            }
        }
    
    def _register_event_handlers(self):
        """æ³¨å†Œäº‹ä»¶å¤„ç†å™¨"""
        # æ³¨å†Œè¯†åˆ«å®Œæˆäº‹ä»¶å¤„ç†å™¨
        self.event_bus.subscribe(EventType.RECOGNITION_COMPLETE, self._handle_recognition_complete)
        
        # æ³¨å†Œæ–‡æœ¬å¤„ç†å®Œæˆäº‹ä»¶å¤„ç†å™¨
        self.event_bus.subscribe(EventType.TEXT_PROCESSED, self._handle_text_processed)
        
        # æ³¨å†Œæ•°å€¼æå–å®Œæˆäº‹ä»¶å¤„ç†å™¨
        self.event_bus.subscribe(EventType.MEASUREMENT_EXTRACTED, self._handle_measurement_extracted)
        
        # æ³¨å†Œé”™è¯¯äº‹ä»¶å¤„ç†å™¨
        self.event_bus.subscribe(EventType.ERROR_OCCURRED, self._handle_error)
    
    def start(self):
        """å¯åŠ¨ç³»ç»Ÿ"""
        try:
            if self.running:
                logging.warning("âš ï¸ ç³»ç»Ÿå·²ç»åœ¨è¿è¡Œä¸­")
                return False
            
            logging.info("â–¶ï¸ å¯åŠ¨å¼‚æ­¥è¯­éŸ³è¾“å…¥ç³»ç»Ÿ...")
            
            # å¼‚æ­¥åˆå§‹åŒ–å¹¶å¯åŠ¨ç³»ç»Ÿ
            self.loop.run_until_complete(self._start_async())
            
            # è¿è¡Œäº‹ä»¶å¾ªç¯
            try:
                self.loop.run_forever()
            except KeyboardInterrupt:
                logging.info("ğŸ›‘ ç”¨æˆ·ä¸­æ–­")
            except Exception as e:
                logging.error(f"âŒ äº‹ä»¶å¾ªç¯å¼‚å¸¸: {e}")
            finally:
                # ä¼˜é›…å…³é—­ç³»ç»Ÿ
                self.loop.run_until_complete(self._stop_async())
                
                # å…³é—­äº‹ä»¶å¾ªç¯
                self.loop.close()
            
            return True
        except Exception as e:
            logging.error(f"âŒ ç³»ç»Ÿå¯åŠ¨å¤±è´¥: {e}")
            return False
    
    async def _start_async(self):
        """å¼‚æ­¥å¯åŠ¨ç³»ç»Ÿ"""
        try:
            # åˆå§‹åŒ–TTSç®¡ç†å™¨
            if self.tts_manager:
                await self.tts_manager.initialize()
            
            # å¯åŠ¨éŸ³é¢‘æµæ§åˆ¶å™¨
            if not await self.audio_stream_controller.start():
                raise Exception("éŸ³é¢‘æµæ§åˆ¶å™¨å¯åŠ¨å¤±è´¥")
            
            # æ ‡è®°ç³»ç»Ÿä¸ºè¿è¡ŒçŠ¶æ€
            self.running = True
            
            # å‘å¸ƒç³»ç»Ÿå¯åŠ¨äº‹ä»¶
            await self.event_bus.publish(EventType.SYSTEM_STARTED)
            
            logging.info("âœ… å¼‚æ­¥è¯­éŸ³è¾“å…¥ç³»ç»Ÿå¯åŠ¨æˆåŠŸ")
        except Exception as e:
            logging.error(f"âŒ å¼‚æ­¥å¯åŠ¨ç³»ç»Ÿå¤±è´¥: {e}")
            await self._stop_async()
            raise
    
    async def _stop_async(self):
        """å¼‚æ­¥åœæ­¢ç³»ç»Ÿ"""
        try:
            if not self.running:
                logging.warning("âš ï¸ ç³»ç»Ÿå·²ç»åœæ­¢")
                return False
            
            logging.info("â¹ï¸ åœæ­¢å¼‚æ­¥è¯­éŸ³è¾“å…¥ç³»ç»Ÿ...")
            
            # æ ‡è®°ç³»ç»Ÿä¸ºéè¿è¡ŒçŠ¶æ€
            self.running = False
            
            # åœæ­¢éŸ³é¢‘æµæ§åˆ¶å™¨
            if self.audio_stream_controller:
                await self.audio_stream_controller.stop()
            
            # å–æ¶ˆæ‰€æœ‰ä»»åŠ¡
            if self.task_manager:
                await self.task_manager.cancel_all_tasks()
            
            # æ¸…ç†TTSç®¡ç†å™¨
            if self.tts_manager:
                await self.tts_manager.cleanup()
            
            # æ¸…ç†æ•°æ®å¯¼å‡ºå™¨
            if self.data_exporter:
                await self.data_exporter.cleanup()
            
            # å‘å¸ƒç³»ç»Ÿåœæ­¢äº‹ä»¶
            await self.event_bus.publish(EventType.SYSTEM_STOPPED)
            
            logging.info("âœ… å¼‚æ­¥è¯­éŸ³è¾“å…¥ç³»ç»Ÿåœæ­¢æˆåŠŸ")
            return True
        except Exception as e:
            logging.error(f"âŒ å¼‚æ­¥åœæ­¢ç³»ç»Ÿå¤±è´¥: {e}")
            return False
    
    async def _handle_audio_data_available(self, audio_data):
        """å¤„ç†éŸ³é¢‘æ•°æ®å¯ç”¨äº‹ä»¶"""
        try:
            # åˆ›å»ºè¯†åˆ«ä»»åŠ¡
            await self.task_manager.create_task(
                self._process_audio_data_async(audio_data),
                task_name="AudioRecognition"
            )
        except Exception as e:
            logging.error(f"âŒ å¤„ç†éŸ³é¢‘æ•°æ®å¤±è´¥: {e}")
            await self.event_bus.publish(EventType.ERROR_OCCURRED, {
                'error': str(e),
                'context': 'éŸ³é¢‘æ•°æ®å¤„ç†'
            })
    
    async def _process_audio_data_async(self, audio_data):
        """å¼‚æ­¥å¤„ç†éŸ³é¢‘æ•°æ®"""
        try:
            # å¼‚æ­¥è¯†åˆ«è¯­éŸ³
            text = await self.voice_recognizer.recognize_async(audio_data)
            
            # å‘å¸ƒè¯†åˆ«å®Œæˆäº‹ä»¶
            await self.event_bus.publish(EventType.RECOGNITION_COMPLETE, text)
        except Exception as e:
            logging.error(f"âŒ è¯­éŸ³è¯†åˆ«å¤±è´¥: {e}")
            await self.event_bus.publish(EventType.RECOGNITION_FAILED, {
                'error': str(e)
            })
    
    async def _handle_recognition_complete(self, text):
        """å¤„ç†è¯†åˆ«å®Œæˆäº‹ä»¶"""
        try:
            # å¤„ç†æ–‡æœ¬
            processed_text = self.text_processor.process_text(text)
            
            # å‘å¸ƒæ–‡æœ¬å¤„ç†å®Œæˆäº‹ä»¶
            await self.event_bus.publish(EventType.TEXT_PROCESSED, processed_text)
        except Exception as e:
            logging.error(f"âŒ å¤„ç†è¯†åˆ«ç»“æœå¤±è´¥: {e}")
            await self.event_bus.publish(EventType.ERROR_OCCURRED, {
                'error': str(e),
                'context': 'è¯†åˆ«ç»“æœå¤„ç†'
            })
    
    async def _handle_text_processed(self, processed_text):
        """å¤„ç†æ–‡æœ¬å¤„ç†å®Œæˆäº‹ä»¶"""
        try:
            # æå–æ•°å€¼
            measurements = self.text_processor.extract_measurements(processed_text)
            
            # å‘å¸ƒæ•°å€¼æå–å®Œæˆäº‹ä»¶
            await self.event_bus.publish(EventType.MEASUREMENT_EXTRACTED, {
                'measurements': measurements,
                'original_text': processed_text
            })
        except Exception as e:
            logging.error(f"âŒ æå–æ•°å€¼å¤±è´¥: {e}")
            await self.event_bus.publish(EventType.ERROR_OCCURRED, {
                'error': str(e),
                'context': 'æ•°å€¼æå–'
            })
    
    async def _handle_measurement_extracted(self, data):
        """å¤„ç†æ•°å€¼æå–å®Œæˆäº‹ä»¶"""
        try:
            measurements = data['measurements']
            original_text = data['original_text']
            
            # å¯¼å‡ºæ•°æ®åˆ°Excel
            if self.data_exporter:
                await self.task_manager.create_task(
                    self.data_exporter.append_with_text_async(original_text),
                    task_name="DataExport"
                )
            
            # TTSæ’­æŠ¥ç»“æœ
            if self.tts_manager:
                await self.task_manager.create_task(
                    self.tts_manager.speak(f"æˆåŠŸæå–æ•°å€¼: {measurements}"),
                    task_name="TTSAnnouncement"
                )
        except Exception as e:
            logging.error(f"âŒ å¤„ç†æå–ç»“æœå¤±è´¥: {e}")
            await self.event_bus.publish(EventType.ERROR_OCCURRED, {
                'error': str(e),
                'context': 'æå–ç»“æœå¤„ç†'
            })
    
    async def _handle_error(self, error_data):
        """å¤„ç†é”™è¯¯äº‹ä»¶"""
        error = error_data.get('error', 'Unknown error')
        context = error_data.get('context', 'Unknown context')
        logging.error(f"âŒ ç³»ç»Ÿé”™è¯¯ ({context}): {error}")
        
        # è¿™é‡Œå¯ä»¥æ·»åŠ é”™è¯¯å¤„ç†é€»è¾‘
        # ä¾‹å¦‚é‡è¯•æ“ä½œã€é™çº§æœåŠ¡ã€å‘é€é€šçŸ¥ç­‰
```

### 7.2 ä¸»ç¨‹åºå…¥å£

```python
# ä¸»ç¨‹åºå…¥å£
if __name__ == "__main__":
    import sys
    
    # é…ç½®æ—¥å¿—
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        handlers=[
            logging.StreamHandler(),
            logging.FileHandler('voice_input_system.log', encoding='utf-8')
        ]
    )
    
    # æ•è·æœªå¤„ç†çš„å¼‚å¸¸
    def handle_uncaught_exception(exc_type, exc_value, exc_traceback):
        """å¤„ç†æœªæ•è·çš„å¼‚å¸¸"""
        if issubclass(exc_type, KeyboardInterrupt):
            sys.__excepthook__(exc_type, exc_value, exc_traceback)
            return
        
        logging.critical("æœªæ•è·çš„å¼‚å¸¸", exc_info=(exc_type, exc_value, exc_traceback))
    
    sys.excepthook = handle_uncaught_exception
    
    # åˆ›å»ºå¹¶å¯åŠ¨ç³»ç»Ÿ
    try:
        system = AsyncVoiceInputSystem()
        sys.exit(0 if system.start() else 1)
    except Exception as e:
        logging.critical(f"ç³»ç»Ÿå¯åŠ¨å¤±è´¥: {e}")
        sys.exit(1)
```

## 8. æœ€ä½³å®è·µä¸å»ºè®®

### 8.1 å¼‚æ­¥ç¼–ç¨‹æœ€ä½³å®è·µ

1. **ä½¿ç”¨asyncio.run()**ï¼šå¯¹äºç®€å•åº”ç”¨ï¼Œä½¿ç”¨`asyncio.run()`æ¥è¿è¡Œä¸»åç¨‹
2. **é¿å…é˜»å¡æ“ä½œ**ï¼šä¸è¦åœ¨å¼‚æ­¥ä»£ç ä¸­ä½¿ç”¨é˜»å¡å¼IOæ“ä½œ
3. **ä½¿ç”¨await**ï¼šå§‹ç»ˆä½¿ç”¨`await`æ¥ç­‰å¾…åç¨‹å®Œæˆ
4. **ä½¿ç”¨async with**ï¼šå¯¹äºéœ€è¦å¼‚æ­¥ä¸Šä¸‹æ–‡ç®¡ç†çš„èµ„æºï¼Œä½¿ç”¨`async with`
5. **ä½¿ç”¨async for**ï¼šå¯¹äºå¼‚æ­¥è¿­ä»£å™¨ï¼Œä½¿ç”¨`async for`
6. **é¿å…é•¿æ—¶é—´è¿è¡Œçš„åŒæ­¥å‡½æ•°**ï¼šå¦‚æœå¿…é¡»ä½¿ç”¨ï¼Œè€ƒè™‘ä½¿ç”¨`loop.run_in_executor()`

### 8.2 ä»»åŠ¡ç®¡ç†æœ€ä½³å®è·µ

1. **è·Ÿè¸ªæ‰€æœ‰ä»»åŠ¡**ï¼šç¡®ä¿æ¯ä¸ªåˆ›å»ºçš„ä»»åŠ¡éƒ½è¢«è·Ÿè¸ª
2. **è®¾ç½®åˆç†çš„è¶…æ—¶**ï¼šä¸ºé•¿æ—¶é—´è¿è¡Œçš„ä»»åŠ¡è®¾ç½®è¶…æ—¶
3. **ä¼˜é›…å–æ¶ˆä»»åŠ¡**ï¼šä½¿ç”¨`task.cancel()`å’Œ`await task`ç»„åˆæ¥å–æ¶ˆä»»åŠ¡
4. **å¤„ç†CancelledError**ï¼šåœ¨åç¨‹ä¸­æ­£ç¡®å¤„ç†`CancelledError`å¼‚å¸¸
5. **ä½¿ç”¨shieldä¿æŠ¤å…³é”®ä»»åŠ¡**ï¼šä½¿ç”¨`asyncio.shield()`ä¿æŠ¤ä¸åº”è¯¥è¢«å–æ¶ˆçš„å…³é”®ä»»åŠ¡

### 8.3 é˜²æ­¢èµ„æºæ³„æ¼çš„å»ºè®®

1. **ä½¿ç”¨ä¸Šä¸‹æ–‡ç®¡ç†å™¨**ï¼šä¸ºèµ„æºåˆ›å»ºä¸Šä¸‹æ–‡ç®¡ç†å™¨ï¼Œç¡®ä¿èµ„æºè¢«æ­£ç¡®é‡Šæ”¾
2. **å®ç°ä¼˜é›…å…³é—­**ï¼šä¸ºæ¯ä¸ªç»„ä»¶å®ç°`cleanup()`æˆ–`shutdown()`æ–¹æ³•
3. **é¿å…å¾ªç¯å¼•ç”¨**ï¼šæ³¨æ„é¿å…å¯¹è±¡ä¹‹é—´çš„å¾ªç¯å¼•ç”¨ï¼Œè¿™å¯èƒ½å¯¼è‡´èµ„æºæ³„æ¼
4. **å®šæœŸæ£€æŸ¥èµ„æºä½¿ç”¨æƒ…å†µ**ï¼šç›‘æ§å†…å­˜å’Œæ–‡ä»¶å¥æŸ„ç­‰èµ„æºçš„ä½¿ç”¨æƒ…å†µ
5. **ä½¿ç”¨å¼±å¼•ç”¨**ï¼šå¯¹äºå¯èƒ½å¯¼è‡´å¾ªç¯å¼•ç”¨çš„æƒ…å†µï¼Œè€ƒè™‘ä½¿ç”¨å¼±å¼•ç”¨

### 8.4 è°ƒè¯•å’Œæ•…éšœæ’é™¤

1. **å¯ç”¨è¯¦ç»†æ—¥å¿—**ï¼šåœ¨å¼€å‘å’Œè°ƒè¯•é˜¶æ®µï¼Œå¯ç”¨è¯¦ç»†æ—¥å¿—
2. **ä½¿ç”¨aiomonitor**ï¼šä½¿ç”¨`aiomonitor`æ¥ç›‘æ§å’Œè°ƒè¯•è¿è¡Œä¸­çš„å¼‚æ­¥åº”ç”¨
3. **æ£€æŸ¥æœªå®Œæˆçš„ä»»åŠ¡**ï¼šåœ¨ç³»ç»Ÿå…³é—­å‰æ£€æŸ¥æ˜¯å¦æœ‰æœªå®Œæˆçš„ä»»åŠ¡
4. **ä½¿ç”¨asyncio debugæ¨¡å¼**ï¼šé€šè¿‡è®¾ç½®`PYTHONASYNCIODEBUG=1`ç¯å¢ƒå˜é‡å¯ç”¨asyncioè°ƒè¯•æ¨¡å¼
5. **ä½¿ç”¨faulthandler**ï¼šå¯ç”¨`faulthandler`æ¨¡å—æ¥è·å–æ›´è¯¦ç»†çš„å´©æºƒä¿¡æ¯

## 9. å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ

### 9.1 Task was destroyed but it is pending!

**é—®é¢˜æè¿°**ï¼šå½“ç³»ç»Ÿå…³é—­æ—¶ï¼Œå‡ºç°"Task was destroyed but it is pending!"é”™è¯¯ã€‚

**åŸå› åˆ†æ**ï¼šè¿™é€šå¸¸æ˜¯å› ä¸ºåœ¨äº‹ä»¶å¾ªç¯å…³é—­æ—¶ï¼Œä»æœ‰æœªå®Œæˆçš„å¼‚æ­¥ä»»åŠ¡ã€‚

**è§£å†³æ–¹æ¡ˆ**ï¼š
1. å®ç°å®Œå–„çš„ä»»åŠ¡è·Ÿè¸ªæœºåˆ¶ï¼Œç¡®ä¿æ‰€æœ‰ä»»åŠ¡éƒ½è¢«å–æ¶ˆå’Œæ¸…ç†
2. åœ¨ç³»ç»Ÿå…³é—­æ—¶ï¼Œæ˜¾å¼å–æ¶ˆæ‰€æœ‰ä»»åŠ¡å¹¶ç­‰å¾…å®ƒä»¬å®Œæˆ
3. ä½¿ç”¨`asyncio.gather(*tasks, return_exceptions=True)`æ¥ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
4. ä¸ºä»»åŠ¡è®¾ç½®åˆç†çš„è¶…æ—¶ï¼Œé¿å…ä»»åŠ¡æ— é™æœŸè¿è¡Œ

### 9.2 éŸ³é¢‘æµä¸­æ–­

**é—®é¢˜æè¿°**ï¼šéŸ³é¢‘æµåœ¨è¿è¡Œä¸€æ®µæ—¶é—´åä¸­æ–­ã€‚

**åŸå› åˆ†æ**ï¼šå¯èƒ½æ˜¯éŸ³é¢‘è®¾å¤‡é—®é¢˜ã€ç¼“å†²åŒºæº¢å‡ºæˆ–èµ„æºæ³„æ¼ã€‚

**è§£å†³æ–¹æ¡ˆ**ï¼š
1. å®ç°éŸ³é¢‘æµå¥åº·æ£€æŸ¥æœºåˆ¶
2. ä¸ºéŸ³é¢‘ç¼“å†²åŒºè®¾ç½®åˆç†çš„å¤§å°å’Œè¶…æ—¶
3. å®šæœŸæ¸…ç†éŸ³é¢‘ç¼“å†²åŒºï¼Œé¿å…æº¢å‡º
4. å®ç°éŸ³é¢‘æµè‡ªåŠ¨é‡è¿æœºåˆ¶

### 9.3 TTSæ’­æŠ¥ä¸è¯­éŸ³è¯†åˆ«å¾ªç¯

**é—®é¢˜æè¿°**ï¼šTTSæ’­æŠ¥çš„å†…å®¹è¢«éº¦å…‹é£é‡æ–°æ•è·ï¼Œå¯¼è‡´æ— é™å¾ªç¯ã€‚

**åŸå› åˆ†æ**ï¼šç³»ç»Ÿæ²¡æœ‰åŒºåˆ†ç”¨æˆ·è¯­éŸ³å’ŒTTSæ’­æŠ¥çš„è¯­éŸ³ã€‚

**è§£å†³æ–¹æ¡ˆ**ï¼š
1. å®ç°TTSåé¦ˆæ£€æµ‹æœºåˆ¶ï¼Œè·³è¿‡åŒ…å«ç‰¹å®šå…³é”®è¯çš„æ–‡æœ¬
2. ä½¿ç”¨éŸ³é¢‘æ’­æ”¾æ—¶çš„é™éŸ³æ£€æµ‹
3. åœ¨TTSæ’­æŠ¥æ—¶ä¸´æ—¶æš‚åœè¯­éŸ³è¯†åˆ«
4. ä¸ºTTSæ’­æŠ¥æ·»åŠ ç‰¹æ®Šæ ‡è®°ï¼Œåœ¨è¯†åˆ«æ—¶è¿‡æ»¤æ‰

### 9.4 é«˜CPUå ç”¨ç‡

**é—®é¢˜æè¿°**ï¼šç³»ç»Ÿè¿è¡Œæ—¶CPUå ç”¨ç‡è¿‡é«˜ã€‚

**åŸå› åˆ†æ**ï¼šå¯èƒ½æ˜¯å› ä¸ºå¼‚æ­¥å¾ªç¯ä¸­æ²¡æœ‰é€‚å½“çš„æš‚åœï¼Œæˆ–è€…ä»»åŠ¡è¿‡äºå¯†é›†ã€‚

**è§£å†³æ–¹æ¡ˆ**ï¼š
1. åœ¨å¼‚æ­¥å¾ªç¯ä¸­æ·»åŠ `await asyncio.sleep(0.001)`ç­‰çŸ­æš‚æš‚åœ
2. é™åˆ¶å¹¶å‘ä»»åŠ¡æ•°
3. ä¼˜åŒ–ä»»åŠ¡å¤„ç†é€»è¾‘ï¼Œå‡å°‘ä¸å¿…è¦çš„è®¡ç®—
4. ä½¿ç”¨æ€§èƒ½åˆ†æå·¥å…·è¯†åˆ«æ€§èƒ½ç“¶é¢ˆ

## 10. æ€»ç»“

æœ¬æ–¹æ¡ˆæä¾›äº†ä¸€ä¸ªå®Œæ•´çš„å¼‚æ­¥å¤„ç†æ¡†æ¶è®¾è®¡ä¸å®ç°ï¼Œé‡ç‚¹è§£å†³äº†ä»¥ä¸‹é—®é¢˜ï¼š

1. **å¼‚æ­¥ä»»åŠ¡ç”Ÿå‘½å‘¨æœŸç®¡ç†**ï¼šé€šè¿‡ä»»åŠ¡ç®¡ç†å™¨å®ç°äº†ä»»åŠ¡çš„åˆ›å»ºã€è·Ÿè¸ªã€å–æ¶ˆå’Œæ¸…ç†
2. **èµ„æºæ³„æ¼é˜²æ­¢**ï¼šé€šè¿‡å®Œå–„çš„æ¸…ç†æœºåˆ¶ï¼Œé¿å…äº†"Task was destroyed but it is pending!"é”™è¯¯
3. **ç³»ç»Ÿç¨³å®šæ€§**ï¼šé€šè¿‡äº‹ä»¶é©±åŠ¨æ¶æ„å’Œç»Ÿä¸€çš„é”™è¯¯å¤„ç†æœºåˆ¶ï¼Œæé«˜äº†ç³»ç»Ÿçš„ç¨³å®šæ€§
4. **é«˜æ•ˆçš„äº‹ä»¶é©±åŠ¨æ¶æ„**ï¼šé€šè¿‡äº‹ä»¶æ€»çº¿å®ç°äº†ç»„ä»¶é—´çš„æ¾è€¦åˆé€šä¿¡

é€šè¿‡é‡‡ç”¨æœ¬æ–¹æ¡ˆï¼Œæ‚¨å¯ä»¥æ„å»ºä¸€ä¸ªé«˜æ•ˆã€ç¨³å®šã€å¯æ‰©å±•çš„å¼‚æ­¥è¯­éŸ³è¾“å…¥ç³»ç»Ÿï¼ŒåŒæ—¶é¿å…å¸¸è§çš„å¼‚æ­¥ç¼–ç¨‹é™·é˜±å’Œèµ„æºæ³„æ¼é—®é¢˜ã€‚