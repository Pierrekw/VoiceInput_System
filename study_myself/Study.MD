> è¿›è¡Œä¸‹ä¸€æ­¥å‰ï¼Œæœ‰äº›é—®é¢˜éœ€è¦è§£ç­”æ¾„æ¸…ã€‚æˆ‘æ˜¯ä¸€ä¸ªpythonå­¦ä¹ è€…ï¼Œç›®å‰åœ¨ç¼–å†™è¿™ä¸ªé¡¹ç›®ã€‚åˆšå­¦ä¹ å’Œäº†è§£äº†asynicoçš„æ–¹æ³•æ¯”å¦‚await, loop,
mutiprocessingç­‰ã€‚è¿˜æ²¡æœ‰å®é™…å¼€å‘è¿‡asynicoçš„é¡¹ç›®ã€‚æˆ‘ç†è§£interfaceå±‚æä¾›äº†æ¥å£æ–¹æ³•ã€‚containerå±‚çš„ç›®çš„æ˜¯ï¼Ÿæˆ‘è®°å¾—asynicoæœ‰ç”Ÿå‘½å‘¨æœŸç®¡ç†ã€‚adapteræ˜¯ç”¨äºè¿‡æ¸¡æˆ–è€…é€æ­¥æ›¿æ¢åŸæ¥æ–¹æ³•çš„ã€‚æˆ‘çš„ç†è§£å¯¹å—

â— ä½ çš„ç†è§£éå¸¸å‡†ç¡®ï¼è®©æˆ‘æ¥è¯¦ç»†è§£ç­”è¿™äº›é—®é¢˜ï¼Œå¹¶è¿›ä¸€æ­¥é˜æ˜å„ä¸ªå±‚çš„ä½œç”¨å’Œå…³ç³»ã€‚

  ğŸ¯ ä½ çš„ç†è§£ç¡®è®¤

  âœ… Interfaceå±‚çš„ä½œç”¨

  å®Œå…¨æ­£ç¡®ï¼ Interfaceå±‚æä¾›äº†æ ‡å‡†å¥‘çº¦ï¼š
  - å®šä¹‰äº†"ç³»ç»Ÿåº”è¯¥åšä»€ä¹ˆ"ï¼ˆæ¥å£æ–¹æ³•ï¼‰
  - å®šä¹‰äº†"æ•°æ®åº”è¯¥æ˜¯ä»€ä¹ˆæ ¼å¼"ï¼ˆæ•°æ®ç±»å’Œæšä¸¾ï¼‰
  - ä¸ºå¼‚æ­¥åŒ–æä¾›äº†ç»Ÿä¸€çš„APIè§„èŒƒ

  âœ… Containerå±‚çš„ç›®çš„

  å¾ˆæ¥è¿‘äº†ï¼ Containerå±‚çš„ä¸»è¦ä½œç”¨æ˜¯ï¼š
  - ä¾èµ–ç®¡ç†: è‡ªåŠ¨åˆ›å»ºå’Œç»„è£…å¯¹è±¡ï¼ˆä½ è¯´çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†ï¼‰
  - æ§åˆ¶åè½¬: ä¸ç”¨æ‰‹åŠ¨newå¯¹è±¡ï¼Œå®¹å™¨è‡ªåŠ¨æ³¨å…¥ä¾èµ–
  - ç”Ÿå‘½å‘¨æœŸç®¡ç†: Transient/Scoped/Singletonä¸‰ç§æ¨¡å¼
  - è§£è€¦: å„ç»„ä»¶ä¹‹é—´ä¸ç›´æ¥ä¾èµ–ï¼Œåªä¾èµ–æ¥å£

  âœ… Adapterçš„è¿‡æ¸¡ä½œç”¨

  å®Œå…¨æ­£ç¡®ï¼ Adapterå±‚å°±æ˜¯ï¼š
  - å®‰å…¨è¿‡æ¸¡: åŒ…è£…ç°æœ‰ä»£ç ï¼Œä¸ç ´ååŸåŠŸèƒ½
  - å…¼å®¹æ€§æ¡¥æ¥: è®©æ—§ä»£ç ç¬¦åˆæ–°æ¥å£
  - é€æ­¥æ›¿æ¢: å¯ä»¥ä¸€ä¸ªä¸ªæ¨¡å—æ¢æˆæ–°å®ç°

  ğŸ”„ æ·±å…¥ç†è§£Containerå’ŒAsyncioçš„å…³ç³»

  Containerçš„"ç”Ÿå‘½å‘¨æœŸç®¡ç†"

  # Containerç®¡ç†çš„æ˜¯å¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸ
  container.register_singleton(IConfigProvider, ConfigProvider)  # æ•´ä¸ªç¨‹åºç”Ÿå‘½å‘¨æœŸ
  container.register_scoped(IDataExporter, ExcelExporter)     # ä¸€ä¸ªè¯·æ±‚ç”Ÿå‘½å‘¨æœŸ
  container.register_transient(IAudioProcessor, AudioProcessor)  # æ¯æ¬¡éƒ½åˆ›å»ºæ–°çš„

  Asyncioçš„"ä»»åŠ¡ç”Ÿå‘½å‘¨æœŸ"

  # Asyncioç®¡ç†çš„æ˜¯å¼‚æ­¥ä»»åŠ¡çš„ç”Ÿå‘½å‘¨æœŸ
  async def process_audio():
      async with container.create_scope():  # ä½œç”¨åŸŸå¼€å§‹
          processor = container.resolve(IAudioProcessor)  # è·å–å¯¹è±¡
          result = await processor.start_recognition_async()  # å¼‚æ­¥ä»»åŠ¡
          exporter = container.resolve(IDataExporter)     # åŒä¸€ä½œç”¨åŸŸå†…è¿”å›ç›¸åŒå¯¹è±¡
          await exporter.append_data_async(result)         # å¼‚æ­¥ä»»åŠ¡
      # ä½œç”¨åŸŸç»“æŸï¼Œscopedå¯¹è±¡è¢«è‡ªåŠ¨æ¸…ç†

  ğŸ—ï¸ å„å±‚åä½œå…³ç³»

  graph TD
      A[åº”ç”¨å±‚ main.py] --> B[Interfaceå±‚ IAudioProcessor]
      B --> C[Containerå±‚ DIContainer]
      C --> D[Adapterå±‚ AudioProcessorAdapter]
      D --> E[ç°æœ‰ä»£ç  AudioCapture]

      F[Asyncioäº‹ä»¶å¾ªç¯] --> C
      F --> D
      F --> E

      C --> G[ç”Ÿå‘½å‘¨æœŸç®¡ç†]
      D --> H[é€‚é…å™¨è½¬æ¢]
      E --> I[å®é™…éŸ³é¢‘å¤„ç†]

  ğŸ’¡ å®é™…å¼€å‘ç¤ºä¾‹

  1. Containerç®¡ç†å¯¹è±¡åˆ›å»º

  # Containerè´Ÿè´£"é€ ä»€ä¹ˆå¯¹è±¡"
  container = DIContainer()
  container.register_singleton(IConfigProvider, ConfigProvider)
  container.register_transient(IAudioProcessor, AudioProcessorAdapter)

  # Containerè´Ÿè´£"å¦‚ä½•ç®¡ç†è¿™äº›å¯¹è±¡"
  processor1 = container.resolve(IAudioProcessor)  # æ–°å®ä¾‹
  processor2 = container.resolve(IAudioProcessor)  # åˆä¸€ä¸ªæ–°å®ä¾‹
  config = container.resolve(IConfigProvider)       # æ€»æ˜¯åŒä¸€ä¸ªå®ä¾‹

  2. Asyncioç®¡ç†ä»»åŠ¡æ‰§è¡Œ

  # Asyncioè´Ÿè´£"å¦‚ä½•æ‰§è¡Œå¼‚æ­¥ä»»åŠ¡"
  async def main():
      # åˆ›å»ºä½œç”¨åŸŸï¼ˆContainerçš„åŠŸèƒ½ï¼‰
      async with container.create_scope():
          # å¼‚æ­¥ä»»åŠ¡1ï¼šè¯­éŸ³è¯†åˆ«
          processor = container.resolve(IAudioProcessor)
          audio_task = processor.start_recognition_async()

          # å¼‚æ­¥ä»»åŠ¡2ï¼šæ•°æ®å¤„ç†ï¼ˆä¸ç­‰å¾…audio_taskå®Œæˆï¼‰
          config_task = process_config_async()

          # ç­‰å¾…éŸ³é¢‘è¯†åˆ«å®Œæˆ
          result = await audio_task

          # å¼‚æ­¥ä»»åŠ¡3ï¼šæ•°æ®å¯¼å‡º
          exporter = container.resolve(IDataExporter)
          await exporter.append_data_async(result.buffered_values)

  3. Adapterä½œä¸ºæ¡¥æ¢

  # Adapterè´Ÿè´£"æ—§ä»£ç å¦‚ä½•é€‚é…æ–°æ¥å£"
  class AudioProcessorAdapter(IAudioProcessor):
      async def start_recognition_async(self):
          # æŠŠå¼‚æ­¥è°ƒç”¨è½¬æ¢ä¸ºåŒæ­¥è°ƒç”¨
          loop = asyncio.get_event_loop()
          result = await loop.run_in_executor(
              None,
              self._audio_capture.listen_realtime_vosk
          )

          # è½¬æ¢æ•°æ®æ ¼å¼
          return RecognitionResult(
              final_text=result["final"],
              buffered_values=result["buffered_values"]
          )

  ğŸ“ å­¦ä¹ è·¯å¾„å»ºè®®

  1. ä»ç®€å•å¼€å§‹

  # å…ˆå­¦ä¼šä½¿ç”¨Container
  from container import DIContainer
  from adapters import AudioProcessorAdapter

  container = DIContainer()
  container.register_transient(IAudioProcessor, AudioProcessorAdapter)
  processor = container.resolve(IAudioProcessor)

  2. é€æ­¥åŠ å…¥Asyncio

  # ç„¶åå­¦ä¼šå¼‚æ­¥è°ƒç”¨
  async def simple_async():
      processor = container.resolve(IAudioProcessor)
      result = await processor.start_recognition_async()
      print(f"è¯†åˆ«ç»“æœ: {result.buffered_values}")

  3. ç†è§£ç”Ÿå‘½å‘¨æœŸ

  # ç†è§£ä¸åŒç”Ÿå‘½å‘¨æœŸçš„å½±å“
  def test_lifecycles():
      # Transientï¼šæ¯æ¬¡éƒ½æ˜¯æ–°å¯¹è±¡
      p1 = container.resolve(IAudioProcessor)
      p2 = container.resolve(IAudioProcessor)
      assert p1 is not p2  # True

      # Singletonï¼šæ€»æ˜¯åŒä¸€ä¸ªå¯¹è±¡
      c1 = container.resolve(IConfigProvider)
      c2 = container.resolve(IConfigProvider)
      assert c1 is c2  # True

  ğŸ¤” å¸¸è§ç–‘é—®è§£ç­”

  Q: ä¸ºä»€ä¹ˆè¦åˆ†è¿™ä¹ˆå¤šå±‚ï¼Ÿ

  A: è¿™æ˜¯æ¸è¿›å¼æ”¹é€ çš„å…³é”®ï¼š
  - Interface: å®šä¹‰æ ‡å‡†ï¼ˆä¸å˜ï¼‰
  - Adapter: é€‚é…ç°æœ‰ä»£ç ï¼ˆå¯æ›¿æ¢ï¼‰
  - Container: ç®¡ç†ä¾èµ–å…³ç³»
  - ç°æœ‰ä»£ç : ä¿æŒåŠŸèƒ½ä¸å˜

  Q: Asyncioå’ŒContainerä¼šå†²çªå—ï¼Ÿ

  A: å®Œå…¨ä¸ä¼šï¼å®ƒä»¬åˆ†å·¥ä¸åŒï¼š
  - Container: å¯¹è±¡çš„åˆ›å»ºå’Œç®¡ç†
  - Asyncio: ä»»åŠ¡çš„æ‰§è¡Œå’Œç­‰å¾…

  Q: ä»€ä¹ˆæ—¶å€™ç”¨Containerï¼Œä»€ä¹ˆæ—¶å€™ç›´æ¥newï¼Ÿ

  A: ç®€å•è§„åˆ™ï¼š
  - å¤æ‚é¡¹ç›®ï¼šç”¨Container
  - å°è„šæœ¬ï¼šç›´æ¥new
  - æµ‹è¯•ä»£ç ï¼šç”¨Containerï¼ˆä¾¿äºMockï¼‰

  ğŸš€ å®é™…å¼€å‘å»ºè®®

  1. å…ˆç”¨Containerç®¡ç†ç°æœ‰å¯¹è±¡

  # ç¬¬ä¸€æ­¥ï¼šæŠŠç°æœ‰ä»£ç åŒ…è£…åˆ°Container
  container = DIContainer()
  container.register_singleton(IAudioProcessor,
      lambda: AudioProcessorAdapter(AudioCapture()))

  2. é€æ­¥åŠ å…¥å¼‚æ­¥è°ƒç”¨

  # ç¬¬äºŒæ­¥ï¼šåœ¨å…³é”®åœ°æ–¹ä½¿ç”¨å¼‚æ­¥
  async def enhanced_main():
      processor = container.resolve(IAudioProcessor)
      result = await processor.start_recognition_async()  # æ–°çš„å¼‚æ­¥æ–¹å¼
      # åŸæœ‰çš„åŒæ­¥æ–¹å¼ä¾ç„¶å¯ç”¨
      # processor.start_recognition()  # æ—§çš„åŒæ­¥æ–¹å¼

  3. é€æ­¥æ›¿æ¢å®ç°

  # ç¬¬ä¸‰æ­¥ï¼šå¯ä»¥å†™æ–°çš„å¼‚æ­¥å®ç°
  class AsyncAudioProcessor(IAudioProcessor):
      async def start_recognition_async(self):
          # å…¨æ–°çš„å¼‚æ­¥å®ç°ï¼Œä¸ä¾èµ–æ—§ä»£ç 
          return await self._new_async_implementation()

  # æ³¨å†Œæ–°çš„å®ç°
  container.register_transient(IAudioProcessor, AsyncAudioProcessor)
  
  
  ### main() å‡½æ•°ä¸ system.run() æ‰§è¡Œæµç¨‹åˆ†æ
åœ¨ main_production.py ä¸­ï¼Œ main() å‡½æ•°ä¸ system.run() ä¹‹é—´å­˜åœ¨æ¸…æ™°çš„æ‰§è¡Œæµç¨‹å…³ç³»ï¼Œå¹¶éå¾ªç¯è°ƒç”¨ã€‚ä»¥ä¸‹æ˜¯å®Œæ•´çš„æ‰§è¡Œæµç¨‹è§£æï¼š
 1. ç¨‹åºå¯åŠ¨å…¥å£
ç¨‹åºé€šè¿‡ if __name__ == "__main__" å—ä¸­çš„ asyncio.run(main()) å¯åŠ¨æ•´ä¸ªå¼‚æ­¥æ‰§è¡Œæµç¨‹ã€‚
 2. main() å‡½æ•°çš„ä½œç”¨
```
asyncÂ defÂ main():
Â Â Â Â #Â è®¾ç½®æ—¥å¿—ç³»ç»Ÿ
Â Â Â Â loggerÂ =Â setup_logging()
Â Â Â Â 
Â Â Â Â #Â è®¾ç½®ä¿¡å·å¤„ç†
Â Â Â Â defÂ signal_handler(signum,Â frame):
Â Â Â Â Â Â Â Â logger.info(f"æ”¶åˆ°ä¿¡å·Â {signum}ï¼Œæ­£åœ¨å…³é—­...")
Â Â Â Â Â Â Â Â sys.exit(0)
Â Â Â Â 
Â Â Â Â signal.signal(signal.SIGINT,Â signal_handler)
Â Â Â Â signal.signal(signal.SIGTERM,Â signal_handler)
Â Â Â Â 
Â Â Â Â #Â åˆ›å»ºå¹¶è¿è¡Œç³»ç»Ÿ
Â Â Â Â systemÂ =Â ProductionVoiceSystem()
Â Â Â Â awaitÂ system.run()
```
`main_production.py`

main() å‡½æ•°çš„ä¸»è¦èŒè´£æ˜¯ï¼š

- ç¯å¢ƒå‡†å¤‡ ï¼šè®¾ç½®æ—¥å¿—ç³»ç»Ÿã€é…ç½®ä¿¡å·å¤„ç†å™¨
- å®ä¾‹åˆ›å»º ï¼šåˆ›å»º ProductionVoiceSystem ç±»çš„å®ä¾‹
- å¯åŠ¨ç³»ç»Ÿ ï¼šè°ƒç”¨å¹¶ç­‰å¾… system.run() æ–¹æ³•å®Œæˆ 3. ProductionVoiceSystem ç±»åˆå§‹åŒ–
å½“ system = ProductionVoiceSystem() æ‰§è¡Œæ—¶ï¼Œä¼šè¿›è¡Œï¼š

```
defÂ __init__(self):
Â Â Â Â #Â æ ¸å¿ƒç³»ç»Ÿç»„ä»¶åˆ›å»º
Â Â Â Â self.event_busÂ =Â AsyncEventBus()
Â Â Â Â self.coordinatorÂ =Â SystemCoordinator(self.event_bus)
Â Â Â Â self.audio_processorÂ =Â AsyncAudioProcessor(self.event_bus)
Â Â Â Â self.tts_managerÂ =Â AsyncTTSManager(self.event_bus)
Â Â Â Â self.keyboard_controllerÂ =Â AsyncKeyboardController(self.event_bus)
Â Â Â Â #Â ...å…¶ä»–åˆå§‹åŒ–
```
`main_production.py`

è¿™é‡Œåªåˆ›å»ºäº†ç»„ä»¶å®ä¾‹ï¼Œä½†å°šæœªå¯åŠ¨å®ƒä»¬ã€‚
 4. system.run() æ–¹æ³•çš„æ‰§è¡Œ
å½“ await system.run() è¢«è°ƒç”¨æ—¶ï¼Œæ‰§è¡Œæµç¨‹å¦‚ä¸‹ï¼š

1. 1.
   ç³»ç»Ÿåˆå§‹åŒ– ï¼šè°ƒç”¨ await self.initialize()
   
   - å¯åŠ¨å…¨å±€ä¼˜åŒ–å™¨
   - å¯åŠ¨äº‹ä»¶æ€»çº¿ã€ç³»ç»Ÿåè°ƒå™¨
   - åˆå§‹åŒ–æ‰€æœ‰æ ¸å¿ƒç»„ä»¶
   - æ³¨å†Œç»„ä»¶åˆ°åè°ƒå™¨
   - è®¢é˜…ç³»ç»Ÿäº‹ä»¶
2. 2.
   ç³»ç»Ÿä¿¡æ¯å±•ç¤º ï¼šæ‰“å°ç³»ç»Ÿæ ‡é¢˜å’Œæ§åˆ¶è¯´æ˜
3. 3.
   å¯åŠ¨è¯†åˆ« ï¼šè°ƒç”¨ await self.start_recognition()
   
   - è®¾ç½®è¯†åˆ«æ´»åŠ¨çŠ¶æ€
   - å‘å¸ƒéŸ³é¢‘æµå¼€å§‹äº‹ä»¶
   - åˆ›å»ºè¯­éŸ³è¯†åˆ«å¾ªç¯ä»»åŠ¡
   - æ’­æ”¾TTSç¡®è®¤æ¶ˆæ¯
4. 4.
   ä¸»å¾ªç¯ ï¼šä¿æŒç³»ç»Ÿè¿è¡Œç›´åˆ°çŠ¶æ€å˜ä¸º "stopped"
   
   ```
   whileÂ self.system_stateÂ !=Â "stopped":
   Â Â Â Â awaitÂ asyncio.sleep(1)
   ```
5. 5.
   ç³»ç»Ÿå…³é—­ ï¼šé€šè¿‡ finally å—ç¡®ä¿è°ƒç”¨ await self.shutdown()
   
   - åœæ­¢æ‰€æœ‰ç»„ä»¶
   - æ¸…ç†èµ„æº 5. æ‰§è¡Œæµç¨‹å›¾è§£
```
asyncio.run(main())
Â Â Â Â â”œâ”€â”€Â setup_logging()Â Â #Â è®¾ç½®æ—¥å¿—
Â Â Â Â â”œâ”€â”€Â setup_signal_handlers()Â Â #Â é…ç½®ä¿¡å·å¤„ç†
Â Â Â Â â”œâ”€â”€Â systemÂ =Â ProductionVoiceSystem()Â Â #Â åˆ›å»ºç³»ç»Ÿå®ä¾‹
Â Â Â Â â”‚Â Â Â Â Â Â Â â””â”€â”€Â åˆå§‹åŒ–ç»„ä»¶å®ä¾‹
Â Â Â Â â””â”€â”€Â awaitÂ system.run()Â Â #Â è¿è¡Œç³»ç»Ÿ
Â Â Â Â Â Â Â Â Â Â Â Â â”œâ”€â”€Â awaitÂ self.initialize()Â Â #Â åˆå§‹åŒ–ç³»ç»Ÿ
Â Â Â Â Â Â Â Â Â Â Â Â â”œâ”€â”€Â awaitÂ self.start_recognition()Â Â #Â å¯åŠ¨è¯†åˆ«
Â Â Â Â Â Â Â Â Â Â Â Â â”œâ”€â”€Â ä¸»å¾ªç¯Â (ç­‰å¾…ç³»ç»Ÿåœæ­¢)
Â Â Â Â Â Â Â Â Â Â Â Â â””â”€â”€Â awaitÂ self.shutdown()Â Â #Â å…³é—­ç³»ç»Ÿ
```
### è®¾è®¡æ„å›¾åˆ†æ
è¿™ç§è®¾è®¡éµå¾ªäº†è‰¯å¥½çš„è½¯ä»¶æ¶æ„åŸåˆ™ï¼š

1. 1.
   å…³æ³¨ç‚¹åˆ†ç¦» ï¼š main() è´Ÿè´£ç¯å¢ƒå‡†å¤‡å’Œå¯åŠ¨ï¼Œ ProductionVoiceSystem è´Ÿè´£å…·ä½“ä¸šåŠ¡é€»è¾‘
2. 2.
   å°è£…æ€§ ï¼šç³»ç»Ÿè¿è¡Œçš„å¤æ‚ç»†èŠ‚è¢«å°è£…åœ¨ ProductionVoiceSystem ç±»å†…éƒ¨
3. 3.
   å¼‚æ­¥ç¼–ç¨‹æ¨¡å¼ ï¼šé€šè¿‡ asyncio.run() ç®¡ç†å¼‚æ­¥æ‰§è¡Œæµç¨‹ï¼Œç®€åŒ–äº†å¹¶å‘ä»£ç ç¼–å†™
4. 4.
   èµ„æºç®¡ç† ï¼šä½¿ç”¨ try/finally ç¡®ä¿èµ„æºæ­£ç¡®é‡Šæ”¾ï¼Œå³ä½¿å‘ç”Ÿå¼‚å¸¸
æ€»ä¹‹ï¼Œ main() æ˜¯ç¨‹åºçš„å…¥å£ç‚¹ï¼Œè´Ÿè´£åˆ›å»ºç³»ç»Ÿå®ä¾‹å¹¶å¯åŠ¨å®ƒï¼Œè€Œ system.run() æ˜¯ç³»ç»Ÿå®é™…è¿è¡Œçš„æ ¸å¿ƒæ–¹æ³•ï¼Œå®ç°äº†å®Œæ•´çš„ç³»ç»Ÿç”Ÿå‘½å‘¨æœŸç®¡ç†ã€‚